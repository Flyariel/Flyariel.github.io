<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解ES6新特性之promise篇]]></title>
    <url>%2F2018%2F01%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bpromise%E7%AF%87%2F</url>
    <content type="text"><![CDATA[JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。 promise对象 Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 一个promise有以下几个状态： pending: 初始状态，成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 Promise.all(iterable)：Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。var p = Promise.all([p1,p2,p3]);Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象实例。p的状态由p1、p2、p3决定，分两种情况： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 1234567891011121314151617181920212223242526let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#123; data: 'promise1' &#125;)&#125;)let promise2 = new Promise((resolve, reject) =&gt; &#123; resolve(&#123; data: 'promise2' &#125;)&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; reject(&#123; data: 'promise3' &#125;)&#125;)Promise.all([promise1, promise2]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise2])触发成功啦`);&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise2])触发失败啦`);&#125;)Promise.all([promise1, promise3]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise3])触发成功啦`);&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise3])触发失败啦`);&#125;)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之父子组件通信]]></title>
    <url>%2F2017%2F12%2F27%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[定义父子组件HTML12345678&lt;div class="hello"&gt; &lt;Welcome :message="msg" @contact="comFromChildren"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type="text" name="username" v-model="userName"&gt; &lt;br&gt; &lt;input type="text" name="age" v-model="age"&gt; &lt;br&gt; &lt;a href="javascript:;" @click="addUser"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125; 定义子组件HTML1234&lt;template&gt; &lt;!--接受父组件传来的消息--&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/template&gt; JavaScript1234567export default &#123; name: "welcome", props: ['message'], created() &#123; this.$emit('contact'); //通知父组件 &#125;&#125; 子组件接收父组件数据]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack部署过程中遇到的问题]]></title>
    <url>%2F2017%2F12%2F05%2Fwebpack-md%2F</url>
    <content type="text"><![CDATA[问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼…… 暂时解决方案从其他同事处拷贝了安装好的依赖包，放到项目代码中依然有问题，because……同事的操作系统是Windows，所以拷贝之后，依然有些包不能用：根据报错提示命令执行，终于解决： 暂时留坑在这里，等调试完项目之后再来回顾该问题 /(ㄒoㄒ)/~~]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 下配置Apache本地域名服务器]]></title>
    <url>%2F2017%2F12%2F01%2FMacOS-%E4%B8%8B%E9%85%8D%E7%BD%AEApache%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件 开启Apache虚拟主机功能vi /etc/apache2/httpd.conf打开Apache配置文件，找到Include /private/etc/apache2/extra/httpd-vhosts.conf，放开注释，开启虚拟主机功能: vi /etc/apache2/extra/httpd-vhosts.conf配置虚拟主机： 启动Apache服务，域名访问项目sudo apachectl start，好了，现在可以通过域名访问项目资源了：]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线上问题日志定位手段]]></title>
    <url>%2F2017%2F11%2F30%2Fonline-problem-logs%2F</url>
    <content type="text"><![CDATA[背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径： 找到日志之后，就可以对指定级别的日志文件进行实时监控啦。一般发生问题时该监控error日志，本文以info日志为例： 然后进入软件系统进行相应操作，即可看见操作产生的对应日志了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下查找包含指定内容的文件]]></title>
    <url>%2F2017%2F11%2F30%2FLinux%2F</url>
    <content type="text"><![CDATA[背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类|标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图： 嗯，可以准备下手修改样式了！but……这个样式表在哪里啊？翻遍了文件夹都没找到对应的这个main.css啊！没关系，接下来该我们本文的主角出场了 机智的find命令以本人对Linux模糊的记忆，搜索到了强悍的find命令find .|xargs grep -ri &quot;xxx&quot;：执行，good，找到了一大堆文件：修改样式，上传，查看blog样式，perfect，手工！ 小插曲 为了省去本文的标题、分类、标签等一系列配置，我打算直接复用上一篇文章的配置。这样的话我首先用vim命令新建了该文章的文件Linux下查找文件/内容之find命令.md，然后cat xx.md &gt; Linux下查找文件/内容之find命令.md把xx文件的内容复制到了该文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
