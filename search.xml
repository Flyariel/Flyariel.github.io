<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux学习笔记一：文件权限与目录配置]]></title>
    <url>%2F2018%2F01%2F17%2FLinux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%EF%BC%9A%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[文件属性u start –&gt; permission deny ？老铁，肯定是权限不够 ！虽然你sudo u start了，但我还是想从Linux的文件属性下嘴，和大家一起学习学习Linux的文件权限。话不多说，首先我们执行一下ls -l（先别问为什么，我也不知道），看到以下结果： ls是list的意思，该命令显示文件的文件名与相关属性，参数-l表示以单列格式输出文件的相关信息。 第一列：代表该文件的类型与权限可以看到，第一列一共有10个字符，其中第一个字符代表该文件的类型 [d]：目录 [-]：文件 [l]：连接文件（linkfile） [b]：设备文件里面的可供存储的接口设备 [c]：设备文件里面的串行端口设备，例如键盘、鼠标等 接下来的字符中，以3个为一组，且均为”rwx的3个参数的组合。r代表可读(read)，w代表可写(write)，x代表可执行(execute)，这3个权限的位置不会改变，如果没有权限，则显示为“-”： 第一组：文件所有者的权限，以“Tomorrow.itermcolors”为例，该文件所有者可以读写，但不可执行 第二组：文件所属用户组的权限 第三组：其他非本用户组对此文件的权限 第二列：表示有多少文件名连接到该节点（i-node）关于i-node的相关资料我们在后续学习过程中再探讨 第三列：代表该文件（目录）的“所有者账号” 第四列：代表该文件的所属用户组Linux系统下，用户账号会附属于一个或者多个用户组中。比如用户User1、User2、USer3均属于staff这个用户组，如上图所示“Creative Cloud Files”所属的用户组为staff，该文件的权限为drwxrwxr-x,则用户USer1、USer2、USer3对该文件都具有可读、可写、可执行的权限，但非staff用户组的其他用户对该文件只具备可读、可执行的权限 第五列：代表该文件的容量大小，默认单位为B 第六列：代表该文件的创建日期或最近修改日期 第七列：代表该文件的名称]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS+图片简单实现五角星推荐指数]]></title>
    <url>%2F2018%2F01%2F10%2F%E5%9F%BA%E4%BA%8ECSS%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%BA%94%E8%A7%92%E6%98%9F%E6%8E%A8%E8%8D%90%E6%8C%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[实现原理一张灰色五角星背景图至于底层，一张评分的亮色五角星图至于上层，利用CSS clip属性裁剪亮色五角星长度，实现推荐指数 HTML12345&lt;span class="recommended"&gt; 推荐指数 &lt;i class="stars"&gt;&lt;i class="inner" :style="&#123;clip: rect&#125;"&gt;&lt;/i&gt;&lt;/i&gt; &lt;i&gt;&#123;&#123;baseInfo.recommended&#125;&#125;&lt;/i&gt;&lt;/span&gt; CSS12345678910111213141516171819202122.stars &#123; display: inline-block; vertical-align: top; margin-top: 2px; margin-left: 5px; width: 80px; height: 13px; line-height: 13px; background-image: url("../img/stars.png"); background-size: contain; .inner &#123; display: inline-block; vertical-align: top; width: 80px; height: 13px; line-height: 13px; background-image: url("../img/stars-active.png"); background-size: contain; position: absolute; /*clip: rect(0 73px 13px 0);*/ &#125;&#125; JavaScript1self.rect = 'rect(0,' + (self.baseInfo.recommended / 5) * 80 + 'px, 13px, 0)' 效果]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于NodeJs防御csrf攻击]]></title>
    <url>%2F2018%2F01%2F04%2F%E5%9F%BA%E4%BA%8ENodeJs%E9%98%B2%E6%AD%A2csrf%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行 NodeJs下防御CSRF攻击思路验证 HTTP Referer 字段 HTTP 头中有一个 Referer 字段，它记录了该 HTTP 请求的来源地址，对该地址进行判断，如果同源则通过验证，否则拒绝请求123456789101112refererCheck(req, res, next)&#123; let referer = req.headers.referer; let refererHost = (referer &amp;&amp; referer.replace(/https?:\/\//ig, "").split("/")[0]) || ""; let reg = new RegExp("\\." + app.config.baseURI.replace(/\./g, "\\.") + "$"; if(!reg.test(refererHost))&#123; next(); &#125;&#125;app.get('/api/test', utils.refererCheck, (req, res, next) =&gt; &#123; // dosomething return xxx;&#125;); 以上，当请求/api/test时，站点A会劫持User(c)的请求并判断请求referer来源，如果发现来源于站点，则会拒绝请求 添加 token 并验证在服务器上生成一个token, web端发起的请求都带上token这个参数, 请求中的token与服务端的token不一致,则抛出错误.1、引入npm包csurf12const csrf = require('csurf');const csrfProtection = csrf(&#123;cookie: true&#125;); 2、校验请求1234app.get('/form', csrfProtection, function(req, res) &#123; // pass the csrfToken to the view res.render('send', &#123; csrfToken: req.csrfToken() &#125;)&#125;) 关于csurf模块首先看下源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function csurf (options) &#123; var opts = options || &#123;&#125; // get cookie options var cookie = getCookieOptions(opts.cookie) // get session options var sessionKey = opts.sessionKey || 'session' // get value getter var value = opts.value || defaultValue // token repo var tokens = new Tokens(opts) // ignored methods var ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods if (!Array.isArray(ignoreMethods)) &#123; throw new TypeError('option ignoreMethods must be an array') &#125; // generate lookup var ignoreMethod = getIgnoredMethods(ignoreMethods) return function csrf (req, res, next) &#123; // validate the configuration against request if (!verifyConfiguration(req, sessionKey, cookie)) &#123; return next(new Error('misconfigured csrf')) &#125; // get the secret from the request var secret = getSecret(req, sessionKey, cookie) var token // lazy-load token getter req.csrfToken = function csrfToken () &#123; var sec = !cookie ? getSecret(req, sessionKey, cookie) : secret // use cached token if secret has not changed if (token &amp;&amp; sec === secret) &#123; return token &#125; // generate &amp; set new secret if (sec === undefined) &#123; sec = tokens.secretSync() setSecret(req, res, sessionKey, sec, cookie) &#125; // update changed secret secret = sec // create new token token = tokens.create(secret) return token &#125; // generate &amp; set secret if (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie) &#125; // verify the incoming token if (!ignoreMethod[req.method] &amp;&amp; !tokens.verify(secret, value(req))) &#123; return next(createError(403, 'invalid csrf token', &#123; code: 'EBADCSRFTOKEN' &#125;)) &#125; next() &#125;&#125; 服务端如何生产成token, token存储的位置当csurf()方法被执行时，会为req添加一个方法csrfToken，该方法生成一个token, 并保存session中12345// generate &amp; set secretif (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie)&#125; 服务端校验的token, 可能来自哪里12345678function defaultValue (req) &#123; return (req.body &amp;&amp; req.body._csrf) || (req.query &amp;&amp; req.query._csrf) || (req.headers['csrf-token']) || (req.headers['xsrf-token']) || (req.headers['x-csrf-token']) || (req.headers['x-xsrf-token'])&#125; 从代码上，如果csurlf初始化时没带任何参数，则校验的token使用使用默认的值，默认的token可能来自req.body, req.query, req.header 哪些请求不校验token1234// ignored methodsvar ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods 如果csurlf初始化时没带任何参数，则 get head option方法不做校验 参考文献1、npm csurf]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈ES6新特性之promise篇]]></title>
    <url>%2F2018%2F01%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bpromise%E7%AF%87%2F</url>
    <content type="text"><![CDATA[JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。 promise对象 Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 一个promise有以下几个状态： pending: 初始状态，成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 Promise方法首先附上一段代码，以此来理解Promise.all()、Promise.race()、Promise.resolve()、Promise.reject()方法12345678910111213141516171819202122232425262728293031323334353637383940let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve('promise1 OK')&#125;)let promise2 = new Promise((resolve, reject) =&gt; &#123; resolve('promise2 OK')&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; reject('promise3 fail')&#125;)Promise.all([promise1, promise2]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;)Promise.all([promise1, promise3]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;)Promise.race([promise1, promise2]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise1, promise3]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise3, promise1]).then(res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行失败：$&#123;res&#125;`)&#125;); 由以上代码及运行结果可见 Promise.all(iterable)Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例：var p = Promise.all([promise1, promise2]);该方法接受一个数组作为参数，p的状态由promise1、promise2决定，分两种情况： 只有promise1、promise2的状态都变成fulfilled，p的状态才会变成fulfilled，此时promise1、promise2的返回值组成一个数组，传递给p的回调函数。 只要promise1、promise2之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.race(iterable)该方法同Promise.all()一样的是：也用于将多个Promise实例包装成一个新的Promise实例：var p = Promise.race([promise1, promise3]); || var p = Promise.race([promise1, promise3]);不同的是：当promise1、promise3里的任意一个promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.resolve(value)返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 Promise.reject(reason)返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 Promise原型Promise.prototype.constructor返回被创建的实例函数. 默认为 Promise 函数. Promise.prototype.then(onFulfilled, onRejected)添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. Promise.prototype.catch(onRejected)添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果. 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之父子组件通信]]></title>
    <url>%2F2017%2F12%2F27%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[定义父子组件HTML12345678&lt;div class="hello"&gt; &lt;Welcome :message="msg" @contact="comFromChildren"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type="text" name="username" v-model="userName"&gt; &lt;br&gt; &lt;input type="text" name="age" v-model="age"&gt; &lt;br&gt; &lt;a href="javascript:;" @click="addUser"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125; 定义子组件HTML1234&lt;template&gt; &lt;!--接受父组件传来的消息--&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/template&gt; JavaScript1234567export default &#123; name: "welcome", props: ['message'], created() &#123; this.$emit('contact'); //通知父组件 &#125;&#125; 子组件接收父组件数据]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack部署过程中遇到的问题]]></title>
    <url>%2F2017%2F12%2F05%2Fwebpack-md%2F</url>
    <content type="text"><![CDATA[问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼…… 暂时解决方案从其他同事处拷贝了安装好的依赖包，放到项目代码中依然有问题，because……同事的操作系统是Windows，所以拷贝之后，依然有些包不能用：根据报错提示命令执行，终于解决： 暂时留坑在这里，等调试完项目之后再来回顾该问题 /(ㄒoㄒ)/~~]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 下配置Apache本地域名服务器]]></title>
    <url>%2F2017%2F12%2F01%2FMacOS-%E4%B8%8B%E9%85%8D%E7%BD%AEApache%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件 开启Apache虚拟主机功能vi /etc/apache2/httpd.conf打开Apache配置文件，找到Include /private/etc/apache2/extra/httpd-vhosts.conf，放开注释，开启虚拟主机功能: vi /etc/apache2/extra/httpd-vhosts.conf配置虚拟主机： 启动Apache服务，域名访问项目sudo apachectl start，好了，现在可以通过域名访问项目资源了：]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线上问题日志定位手段]]></title>
    <url>%2F2017%2F11%2F30%2Fonline-problem-logs%2F</url>
    <content type="text"><![CDATA[背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径： 找到日志之后，就可以对指定级别的日志文件进行实时监控啦。一般发生问题时该监控error日志，本文以info日志为例： 然后进入软件系统进行相应操作，即可看见操作产生的对应日志了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下查找包含指定内容的文件]]></title>
    <url>%2F2017%2F11%2F30%2FLinux%2F</url>
    <content type="text"><![CDATA[背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类|标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图： 嗯，可以准备下手修改样式了！but……这个样式表在哪里啊？翻遍了文件夹都没找到对应的这个main.css啊！没关系，接下来该我们本文的主角出场了 机智的find命令以本人对Linux模糊的记忆，搜索到了强悍的find命令find .|xargs grep -ri &quot;xxx&quot;：执行，good，找到了一大堆文件：修改样式，上传，查看blog样式，perfect，手工！ 小插曲 为了省去本文的标题、分类、标签等一系列配置，我打算直接复用上一篇文章的配置。这样的话我首先用vim命令新建了该文章的文件Linux下查找文件/内容之find命令.md，然后cat xx.md &gt; Linux下查找文件/内容之find命令.md把xx文件的内容复制到了该文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
