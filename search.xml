<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于NodeJs防止csrf攻击]]></title>
    <url>%2F2018%2F01%2F04%2F%E5%9F%BA%E4%BA%8ENodeJs%E9%98%B2%E6%AD%A2csrf%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行 NodeJs下防御CSRF攻击思路验证 HTTP Referer 字段 HTTP 头中有一个 Referer 字段，它记录了该 HTTP 请求的来源地址，对该地址进行判断，如果同源则通过验证，否则拒绝请求123456789101112refererCheck(req, res, next)&#123; let referer = req.headers.referer; let refererHost = (referer &amp;&amp; referer.replace(/https?:\/\//ig, "").split("/")[0]) || ""; let reg = new RegExp("\\." + app.config.baseURI.replace(/\./g, "\\.") + "$"; if(!reg.test(refererHost))&#123; next(); &#125;&#125;app.get('/api/test', utils.refererCheck, (req, res, next) =&gt; &#123; // dosomething return xxx;&#125;); 以上，当请求/api/test时，站点A会劫持User(c)的请求并判断请求referer来源，如果发现来源于站点，则会拒绝请求 添加 token 并验证在服务器上生成一个token, web端发起的请求都带上token这个参数, 请求中的token与服务端的token不一致,则抛出错误.1、引入npm包csurf12const csrf = require('csurf');const csrfProtection = csrf(&#123;cookie: true&#125;); 2、校验请求1234app.get('/form', csrfProtection, function(req, res) &#123; // pass the csrfToken to the view res.render('send', &#123; csrfToken: req.csrfToken() &#125;)&#125;) 关于csurf模块首先看下源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function csurf (options) &#123; var opts = options || &#123;&#125; // get cookie options var cookie = getCookieOptions(opts.cookie) // get session options var sessionKey = opts.sessionKey || 'session' // get value getter var value = opts.value || defaultValue // token repo var tokens = new Tokens(opts) // ignored methods var ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods if (!Array.isArray(ignoreMethods)) &#123; throw new TypeError('option ignoreMethods must be an array') &#125; // generate lookup var ignoreMethod = getIgnoredMethods(ignoreMethods) return function csrf (req, res, next) &#123; // validate the configuration against request if (!verifyConfiguration(req, sessionKey, cookie)) &#123; return next(new Error('misconfigured csrf')) &#125; // get the secret from the request var secret = getSecret(req, sessionKey, cookie) var token // lazy-load token getter req.csrfToken = function csrfToken () &#123; var sec = !cookie ? getSecret(req, sessionKey, cookie) : secret // use cached token if secret has not changed if (token &amp;&amp; sec === secret) &#123; return token &#125; // generate &amp; set new secret if (sec === undefined) &#123; sec = tokens.secretSync() setSecret(req, res, sessionKey, sec, cookie) &#125; // update changed secret secret = sec // create new token token = tokens.create(secret) return token &#125; // generate &amp; set secret if (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie) &#125; // verify the incoming token if (!ignoreMethod[req.method] &amp;&amp; !tokens.verify(secret, value(req))) &#123; return next(createError(403, 'invalid csrf token', &#123; code: 'EBADCSRFTOKEN' &#125;)) &#125; next() &#125;&#125; 服务端如何生产成token, token存储的位置当csurf()方法被执行时，会为req添加一个方法csrfToken，该方法生成一个token, 并保存session中12345// generate &amp; set secretif (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie)&#125; 服务端校验的token, 可能来自哪里12345678function defaultValue (req) &#123; return (req.body &amp;&amp; req.body._csrf) || (req.query &amp;&amp; req.query._csrf) || (req.headers['csrf-token']) || (req.headers['xsrf-token']) || (req.headers['x-csrf-token']) || (req.headers['x-xsrf-token'])&#125; 从代码上，如果csurlf初始化时没带任何参数，则校验的token使用使用默认的值，默认的token可能来自req.body, req.query, req.header 哪些请求不校验token1234// ignored methodsvar ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods 如果csurlf初始化时没带任何参数，则 get head option方法不做校验 参考文献1、npm csurf]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ES6新特性之promise篇]]></title>
    <url>%2F2018%2F01%2F03%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bpromise%E7%AF%87%2F</url>
    <content type="text"><![CDATA[JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。 promise对象 Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 一个promise有以下几个状态： pending: 初始状态，成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 Promise.all(iterable)：Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。var p = Promise.all([p1,p2,p3]);Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象实例。p的状态由p1、p2、p3决定，分两种情况： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 1234567891011121314151617181920212223242526let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve(&#123; data: 'promise1' &#125;)&#125;)let promise2 = new Promise((resolve, reject) =&gt; &#123; resolve(&#123; data: 'promise2' &#125;)&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; reject(&#123; data: 'promise3' &#125;)&#125;)Promise.all([promise1, promise2]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise2])触发成功啦`);&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise2])触发失败啦`);&#125;)Promise.all([promise1, promise3]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise3])触发成功啦`);&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise3])触发失败啦`);&#125;)]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习笔记之父子组件通信]]></title>
    <url>%2F2017%2F12%2F27%2FVue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[定义父子组件HTML12345678&lt;div class="hello"&gt; &lt;Welcome :message="msg" @contact="comFromChildren"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type="text" name="username" v-model="userName"&gt; &lt;br&gt; &lt;input type="text" name="age" v-model="age"&gt; &lt;br&gt; &lt;a href="javascript:;" @click="addUser"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125; 定义子组件HTML1234&lt;template&gt; &lt;!--接受父组件传来的消息--&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/template&gt; JavaScript1234567export default &#123; name: "welcome", props: ['message'], created() &#123; this.$emit('contact'); //通知父组件 &#125;&#125; 子组件接收父组件数据]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack部署过程中遇到的问题]]></title>
    <url>%2F2017%2F12%2F05%2Fwebpack-md%2F</url>
    <content type="text"><![CDATA[问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼…… 暂时解决方案从其他同事处拷贝了安装好的依赖包，放到项目代码中依然有问题，because……同事的操作系统是Windows，所以拷贝之后，依然有些包不能用：根据报错提示命令执行，终于解决： 暂时留坑在这里，等调试完项目之后再来回顾该问题 /(ㄒoㄒ)/~~]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS 下配置Apache本地域名服务器]]></title>
    <url>%2F2017%2F12%2F01%2FMacOS-%E4%B8%8B%E9%85%8D%E7%BD%AEApache%E6%9C%AC%E5%9C%B0%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件 开启Apache虚拟主机功能vi /etc/apache2/httpd.conf打开Apache配置文件，找到Include /private/etc/apache2/extra/httpd-vhosts.conf，放开注释，开启虚拟主机功能: vi /etc/apache2/extra/httpd-vhosts.conf配置虚拟主机： 启动Apache服务，域名访问项目sudo apachectl start，好了，现在可以通过域名访问项目资源了：]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线上问题日志定位手段]]></title>
    <url>%2F2017%2F11%2F30%2Fonline-problem-logs%2F</url>
    <content type="text"><![CDATA[背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径： 找到日志之后，就可以对指定级别的日志文件进行实时监控啦。一般发生问题时该监控error日志，本文以info日志为例： 然后进入软件系统进行相应操作，即可看见操作产生的对应日志了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下查找包含指定内容的文件]]></title>
    <url>%2F2017%2F11%2F30%2FLinux%2F</url>
    <content type="text"><![CDATA[背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类|标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图： 嗯，可以准备下手修改样式了！but……这个样式表在哪里啊？翻遍了文件夹都没找到对应的这个main.css啊！没关系，接下来该我们本文的主角出场了 机智的find命令以本人对Linux模糊的记忆，搜索到了强悍的find命令find .|xargs grep -ri &quot;xxx&quot;：执行，good，找到了一大堆文件：修改样式，上传，查看blog样式，perfect，手工！ 小插曲 为了省去本文的标题、分类、标签等一系列配置，我打算直接复用上一篇文章的配置。这样的话我首先用vim命令新建了该文章的文件Linux下查找文件/内容之find命令.md，然后cat xx.md &gt; Linux下查找文件/内容之find命令.md把xx文件的内容复制到了该文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
