{"meta":{"title":"Ariel's Blog","subtitle":"我想在那里最蓝的大海扬帆 , 绝不管自己能不能回还","description":"沉迷卡农无法自拔","author":"Ariel","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2017-05-21T02:49:54.000Z","updated":"2017-05-21T02:50:33.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-05-21T02:35:24.000Z","updated":"2017-05-26T10:36:07.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-05-21T02:32:55.000Z","updated":"2017-05-21T02:34:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux学习笔记二：文件与目录管理","slug":"Linux-file-directory-manage","date":"2018-03-29T07:01:58.000Z","updated":"2018-04-18T14:44:23.000Z","comments":true,"path":"2018/03/29/Linux-file-directory-manage/","link":"","permalink":"http://yoursite.com/2018/03/29/Linux-file-directory-manage/","excerpt":"目录与路径目录的相关操作首先介绍一下比较特殊的目录，需要牢记脑海： 目录 含义 . 代表此层目录 .. 代表上一层目录 - 代表前一个工作目录 ~ 代表【目前用户身份】所在的家目录 ~arieltian 代表 arieltian 这个用户的家目录 需要注意的是：在所有目录底下都会存在.和..两个目录，根目录的上一层..和根目录自己.是同一个目录。然后再了解下几个常见的目录操作指令 cd：变换目录 pwd：显示当前目录 mkdir：建立一个新的目录 rmdir：删除一个空目录 cd(change directory)用来切换工作目录的指令。结合上文讲到的目录及含义和相对路径与绝对路径，相信大家能够轻松的进行目录切换了。 pwd(print working directory)显示当前工作目录，该指令有可选参数：[-P]，使用该参数后，显示的是当前确切路径，而非链接(link)路径。如下图，/var/log是链接文档，链接到/private/var/log","text":"目录与路径目录的相关操作首先介绍一下比较特殊的目录，需要牢记脑海： 目录 含义 . 代表此层目录 .. 代表上一层目录 - 代表前一个工作目录 ~ 代表【目前用户身份】所在的家目录 ~arieltian 代表 arieltian 这个用户的家目录 需要注意的是：在所有目录底下都会存在.和..两个目录，根目录的上一层..和根目录自己.是同一个目录。然后再了解下几个常见的目录操作指令 cd：变换目录 pwd：显示当前目录 mkdir：建立一个新的目录 rmdir：删除一个空目录 cd(change directory)用来切换工作目录的指令。结合上文讲到的目录及含义和相对路径与绝对路径，相信大家能够轻松的进行目录切换了。 pwd(print working directory)显示当前工作目录，该指令有可选参数：[-P]，使用该参数后，显示的是当前确切路径，而非链接(link)路径。如下图，/var/log是链接文档，链接到/private/var/log mkdir(make directory)建立新目录，有可选参数[-mp]，-m配置文件目录的权限，-p可直接递归创建目录（预设情况下，所需目录得一层一层创建）。 rmdir(remove directory)删除空目录，有可选参数[-p]，-p可递归删除层级目录。需要注意的是，rmdir仅可删除空目录，当目标目录存在下级目录或文件时，该指令会执行失败，如果要强制删除目标目录以及该目录下的所有目录/文件，可使用【rm -r 目标目录】指令 执行文件路径的变量：$PATH以查阅文件属性的指令ls为例，它的完整文件名为：/bin/ls（绝对路径），但是我们在任何一个目录下执行ls指令都会输出信息，而不会发生找不到/bin/ls指令的错误，这其实是在环境变量PATH的帮助下完成的。 当我们在执行ls时，系统会按照PATH的设定去每个PATH定义的目录下搜寻名为ls的可执行文件，如果在PATH定义的目录中含有多个ls可执行文件，先搜寻到的ls指令先被执行 文件与目录管理文件与目录的检视ls指令可以输出文件的一些基本信息。Linux的文件记录的信息其实是非常多的，默认情况下（ls指令不附加参数）显示的文件信息只包括：非隐藏的档名、以档名进行排序及文件名代表的颜色显示。当我们需要知道文件的其他信息时，需要附加额外的参数，具体参数及各自代表的意义如下表： 参数 含义 -a 全部的文件，连同隐藏档一起列出来 -A 全部的文件，连同隐藏档一起列出来，但不包括.与..这两个目录 -d 仅列出目录本身，而不是列出目录内的文件数据 -f 直接列出结果，而不进行排序 -F 根据文件、目录等信息，给予附加数据结构。 -h 将文件容量已易读的方式（如GB、KB等）列出来 -i 列出inode号 -l 长数据串行出，包含文件的属性与权限等等数据 -n 列出UID与GID而非使用者与群组的名称 -r 将排序结果反向输出 -R 连同子目录内容一起列出来，等于该目录下的所有文件都会显示出来 -S 以文件容量大小排序 -t 依时间排序 –time={atime,ctime} 依时间排序 复制、删除与移动cp（复制文件或目录）其指令格式为cp [-adfilprsu] source(来源文件) destination(目标文件)，不同身份的用户执行该指令会有不同的结果产生。cp指令可附加的选项与参数如下表： 参数 含义 -a 相当于 -dr –preserve=all的意思，dr请参考下列说明 -d 若来源文件为链接文件的属性，则复制链接文件属性而非文件本身 -f 为强制（force）的意思，若目标文件已经存在且无法开启，则移除后再尝试一次 -i 若目标文件已经存在时，在覆盖时会先询问动作的进行 -l 进行硬式连结的连接档建立，而非复制文件本身 -p 连同文件的属性一起复制过去，而非使用默认属性 -r 递归持续复制，用于目录的复制行为 -s 复制成为富豪链接文件，亦即[快捷方式]文件 -u destination比source 旧才更新destination，或destination不存在才复制 需要注意的是：在预设条件中，cp的来源文件与目标文件的权限是不同的，目标文件的拥有者通常是指令执行者本身，因此当我们进行备份的时候，一些特殊权限的文件（比如密码文件/etc/sahdow）以及一些配置文件，就需要加上-a或者-p等可以完整复制文件权限的选项才行。来看看实际应用：由于arieltian的身份并不能随意修改文件的拥有者与群组，因此即使加上 -a 选项，也只能复制源文件的相关权限与时间等属性，而不能复制与拥有者、群组相关的权限的。 rm（移除文件或目录）指令格式为rm [-fir] 文件或目录，可选参数如下： 参数 含义 -f 为force的意思，忽略不存在的文件，不会出现警告信息 -i 在删除前会询问使用者是否执行 -r 递归删除，常用于目录的删除 来看看实际应用： mv（移动文件与目录，或重命名）指令格式为mv [-fiu] 文件或目录，可选参数如下： 参数 含义 -f 为force的意思，若目标文件已存在，不会询问而直接覆盖 -i 若目标文件已存在，会询问是否覆盖 -u 若目标文件已存在，且source比较新才更新目标文件 实际应用如下： 获取路径的文件名与目录名一个文件的完整档名包含前面的目录与最终的文件名，在shell script之类的程序中，怎么知道某个完整档名里，哪部分是档名，哪部分是目录名呢？以一个范例来看看basename与dirname的用途： 文件内容查阅直接检视文件内容直接查阅一个文件的内容可以使用cat/tac/nl 这几个指令，每个指令代表的意思和可选参数如下： ◆ cat [-AbEnTv] 参数 含义 -A 相当于 -vET 的整个选项，可列出一些特殊字符而不是空白 -b 列出行号，仅针对非空白行做行号显示，空白行不标行号 -E 将结尾的断行字符 $ 显示出来 -n 打印出行号，连同空白行也会有行号，与 -b 的选项不同 -T 将tab按键以^I显示出来 -v 列出一些看不出来的特殊字符 ◆ tac (反向列式)：与cat指令功能相反，执行该指令会反向输出文件内容 ◆ nl [-bnw]（添加行号打印） 参数 含义 -b 指定行号指定的方式，-b a表示不管是否为空白行，也列出行号，类似于cat -n；-b t则不会列出空白行的行号 -n 列出行号表示的方法。-n ln行号在屏幕的最左方显示;-n rn在自己字段的最有房显示，且不加0;-n rz,同-n rn但要加0 -w 行号字段的占用字符数 翻页检视前面提到的检视文件内容的指令，都是一次性将文件内容输出，more、less指令可翻页检视文件内容。◆ more在more指令运行过程中，有以下几个键是可操作的 空格键：代表向下翻一页 enter：代表向下翻一行 /aaa：代表在more指令输出的内容中，向下查找“aaa”这个关键词 :f：显示出文件名以及目前显示的行数 q：退出more指令 b：代表往回翻页（只对文件生效，对管线无效） ◆ lessless指令相对于more指令更灵活，more指令只能往后查看文件内容，但less指令运行过程中，则可以通过pageup、pagedown等按键来向前向后查阅文件内容。 空格键：代表向下翻一页 pagedown：代表向下翻一页 pageup：代表向上翻一页 /aaa：向下查找“aaa”这个关键词 ?aaa：向上查找“aaa”这个关键词 n：重复上一个查找动作 N：反复的重复上一个查找动作 g：跳到该查阅文件的第一行 G：跳到该查阅文件的最后一行 q：结束less指令 资料撷取前面介绍的指令已经可以帮助我们查阅到文件的内容了，但往往文件内容过多的时候，是需要对输出内容进行撷取的，head和tail指令可以帮助我们实现该需求◆ head [-n number]（输出该文件前number行） ◆ tail [-n number]（输出该文件后number行） tail指令加上-f 参数之后，表示持续侦测指定文件的内容，程序员们常用该指令监控日志哟，想要离开持续侦测模式，只需Ctrl+c即可。 非文本文档的内容检视上面提到的文件内容查阅的相关指令，都是基于纯文本文档的。如果要查阅非文本文档内容，可以使用od指令来实现我们的需求。指令格式为od [-t TYPE] 文件，-t后面可以接各种类型（TYPE）的输出： 参数 含义 a 利用默认字符输出 c 使用ASCII字符输出 d 利用十进制输出数据 f 利用浮点数输出数据 o 利用八进制输出数据 x 利用十六进制输出数据 修改文件事件或新建文档前面在介绍ls指令时，有提到过Linux系统中每个文件会记录许多时间参数，其中有三个主要的变动时间： mtime：文件内容发生改变时，会更新该时间 ctime：文件状态（比如权限/属性）发生改变时，更新该时间 atime：文件内容被读取时（比如使用cat指令读取某个文件内容），更新该时间 当某个文件的上述时间参数异常时，可以使用touch指令更新该文件的时间参数，当目标文件不存在时，touch指令会新建目标文件： 参数 含义 -a 修改atime为当前时间 -c 仅修改文件的时间，若该文件不存在则不建立新文件 -d 后接想要更新的日期（而不是更新为当前日期） -m 仅修改mtime为当前时间 -t 后接想要更新的时间（而不是更新为当前时间） 指令与文件的搜索我们常常需要知道某个文件在系统中的具体存放路径，在Linux系统中，可以使用which、whereis、find指令查找文件的路径 脚本文件的搜索可能你已经知道，在终端里，连续按下两次 [tab] 键就能知道有多少指令可以使用，但知道这些指令存放在哪个位置么？比如常用的ls指令，如果不熟悉Linux的目录结构（可参考该博客网址中介绍Linux目录结构的文章），可以使用which [-a] command指令查找，该指令会根据PATH环境变量定义的路径，去查找可执行文档（如ls指令）的存放路径： 参数 含义 -a 将所有由PATH目录中可以找到的指令均列出，而不止第一个被找到的指令名称 文件档名的搜索除了which指令搜索脚本文件以外，我们还可能需要在系统中搜索文本文档的存放位置，一般我们可优先考虑使用whereis指令来搜索，whereis指令不满足需求的时候可用find指令搜索（find指令会搜索硬盘内的文件系统状态，比较耗时） ◆ whereis [-bmsu] 文件或目录名（由一些特定的目录中寻找指定文件的路径） 参数 含义 -l 列出whereis会去搜索的几个主要目录 -b 只搜索 binary 格式的文件 -m 只搜索在说明文件 manual 路径下的文件 -s 只搜索 source 来源文件 -u 搜索不在上述3个项目中的其他特殊文件 ◆ find [PATH] [option] [action] 该指令的选项以及与选项对应的参数可大致分为4类： 1、与时间有关的选项，共有-atime、-ctime与-mtime，以-mtime为例 参数 含义 -mtime n n为数字，表示n天前的24小时内被更改过内容的文件 -mtime +n n天前（不包含n天本身）被更改过内容的文件 -mtime -n n天前（含n天本身）被更改过内容的文件 -newer file file为一个存在的文件名，表示列出比file还要新的文件 上述参数n若为0则需要注意，0表示当前时间，所以如果要列出某个目录下从现在开始到24小时前有改动过内容的文件，可执行如下指令 2、与使用者或组名有关的参数 参数 含义 -uid n n为用户的账号ID，即UID，这个UID是记录在 /etc/passwd里面与账号名称对应的数字 -gid n n为组名的账号ID，即GID，这个GID是记录在 /etc/group -user name name为用户账号名称，表示列出属于用户 name 的文件 -group name name为组名，表示列出属于 name 组的文件 -nouser 列出不属于任何用户的文件 -nogroup 列出不属于任何群组的文件 3、与文件权限及名称相关的参数 参数 含义 -name filename 搜索文件名为filename的文件 -size [+-]SIZE 搜索比SIZE还要大（+）或者小（-）的文件，SIZE的规格有c:代表byte，k:代表1024bytes。比如要找比50KB还要大的文件可以这样写：-size +50k -type TYPE 搜索文件类型为TYPE的文件，类型主要有：一般正规文件（f）、装置文件（b,c）、目录（d）、链接档（i）、socket（s）及FIFO（p） -perm mode 搜索文件权限刚好等于mode的文件，mode为类似chmod的属性值，比如-rwsr-xr-x的mode为4755 如：想要搜索某个目录下文件名包含‘Linux’关键字的文件，可执行如下指令 4、额外可进行的动作 参数 含义 -exec command command为其他指令，-exec后面可再接其他指令来处理搜索到的结果 比如将上一个例子中找到的文件以 ls -l列出来 结束语拖了2个月，终于还是把Linux的文件和目录管理相关的知识走了一遍，噼里啪啦简单的分享了下，也希望各位阅者有所收获。下一期Linux学习笔记……还在计划中，敬请关注。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Roadmap to becoming a web developer in 2018","slug":"Roadmap-to-becoming-a-web-developer-in-2018","date":"2018-02-27T09:12:06.000Z","updated":"2018-02-27T09:35:25.089Z","comments":true,"path":"2018/02/27/Roadmap-to-becoming-a-web-developer-in-2018/","link":"","permalink":"http://yoursite.com/2018/02/27/Roadmap-to-becoming-a-web-developer-in-2018/","excerpt":"Roadmap to becoming a web developer in 2018 There is a recorded version of this on youtube now. Also, I just created this channel and have got some nice plans for the screencasts so make sure to subscribe to the channel, if you would like :) Below you find a set of charts demonstrating the paths that you can take and the technologies that you would want to adopt in order to become a frontend, backend or a devops. I made these charts for an old professor of mine who wanted something to share with his college students to give them a perspective. If you think that these can be improved in anyway, please do suggest. Did you like this guide and want more of the similar content? Subscribe for the launch of Hugobots or follow me on twitter!","text":"Roadmap to becoming a web developer in 2018 There is a recorded version of this on youtube now. Also, I just created this channel and have got some nice plans for the screencasts so make sure to subscribe to the channel, if you would like :) Below you find a set of charts demonstrating the paths that you can take and the technologies that you would want to adopt in order to become a frontend, backend or a devops. I made these charts for an old professor of mine who wanted something to share with his college students to give them a perspective. If you think that these can be improved in anyway, please do suggest. Did you like this guide and want more of the similar content? Subscribe for the launch of Hugobots or follow me on twitter! 🚀 Introduction 🎨 Front-end Roadmap 👽 Back-end RoadmapFor the backend, personally I would prefer Node.js and PHP 7 for the full time. Plus, I have been experimenting lately with Go and I quite like it. Apart from these, if I have to choose another one, I would go for Ruby. However this is just my personal preference, you can choose any of the shown languages and you will be good. 👷 DevOps Roadmap 🚦 Wrap UpIf you think any of the roadmaps can be improved, please do open a PR with any updates and submit any issues. Also, I will continue to improve this, so you might want to watch/star this repository to revisit. ☑ TODO [X] Add Frontend Roadmap [X] Add Backend Roadmap [X] Add DevOps Roadmap [ ] Add relevant resources for each 👬 ContributionThe roadmaps are built using Balsamiq. Project file can be found at /project-files directory. To modify any of the roadmaps, open Balsamiq, click Project &gt; Import &gt; Mockup JSON, it will open the roadmap for you, update it, upload and update the images in readme and create a PR. Open pull request with improvements Discuss ideas in issues Spread the word Reach out with any feedback Sponsored By Hackr.io - Find &amp; Share the Best Online Programming Courses &amp; Tutorials Highig - Think and its done 搬运自kamranahmedse/developer-roadmap，侵删","categories":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"http://yoursite.com/categories/前端杂谈/"}],"tags":[{"name":"前端杂谈","slug":"前端杂谈","permalink":"http://yoursite.com/tags/前端杂谈/"}]},{"title":"浅析正则表达式","slug":"javascript-RegExp","date":"2018-02-11T07:12:06.000Z","updated":"2018-04-10T05:51:32.445Z","comments":true,"path":"2018/02/11/javascript-RegExp/","link":"","permalink":"http://yoursite.com/2018/02/11/javascript-RegExp/","excerpt":"概念介绍 正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 - - MDN 术语与操作符特殊字符 字符 含义 \\ 匹配将依照下列规则：在非特殊字符之前的反斜杠表示下一个字符是特殊的；特殊字符前的反斜杠则转义其后的特殊字符为字面量。如：/\\d/ 匹配一个数字，/a\\*/ 匹配‘a*’ ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 匹配输入的开始。如：/^a/匹配以a开始的字符 $ 匹配输入的结束。如：/b$/匹配以b结束的字符 * 匹配前一个表达式0次或多次，等价于{0,}。如：/cd*/匹配‘abcdef’中的‘cd’，匹配‘abcef’中的‘c’，但不会匹配‘abdef’中的任何字符。 + 匹配前一个表达式1次或多次，等价于{1,}。如：/a+/匹配了在 ‘candy’ 中的 ‘a’，和在 ‘caaaaaaandy’ 中所有的 ‘a’。 ? 匹配前一个表达式0次或1次，等价于 {0,1}。如：/e?le?/ 匹配 ‘angel’ 中的 ‘el’，和 ‘angle’ 中的 ‘le’ 以及‘oslo’ 中的‘l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），如：/\\d+?/ 匹配‘123abc’中的‘1’ . 匹配除换行符之外的任何单个字符。如：/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 (x) 匹配 ‘x’ 并且记住匹配项。如：/(foo) (bar) \\1 \\2/将会匹配 “foo bar foo bar” 并记住前2个单词。 (?:x) 匹配 ‘x’ 但不记住匹配项。如：/(?:foo){1,2}/，如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。 x(?=y) 匹配 ‘x’ 仅仅当 ‘x’ 后面跟着 ‘y’。如：/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着 ‘Sprat’。但是‘Sprat’不是匹配结果的一部分。 x(?!y) 匹配 ‘x’ 仅仅当 ‘x’ 后面不跟着 ‘y’。如：/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’。 {n} 匹配了前面一个字符刚好发生了n次。如：/a{2}/不会匹配“candy”中的 ‘a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个 ‘a’。 {n,m} 匹配匹配前面的字符至少n次，最多m次。如：/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中得a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。 [xyz] 匹配方括号的中任意字符，包括转义序列，可以使用破折号（-）来指定一个字符范围。如：[abcd] 和[a-d]是一样的。他们都匹配”brisket”中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/都匹配“test.i.ng”中得所有字符。 [^xyz] 匹配任何没有包含在方括号中的字符。如：[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中得‘r’，也匹配“chop”中的‘h’。 [\\b] 匹配一个退格(U+0008)。","text":"概念介绍 正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 - - MDN 术语与操作符特殊字符 字符 含义 \\ 匹配将依照下列规则：在非特殊字符之前的反斜杠表示下一个字符是特殊的；特殊字符前的反斜杠则转义其后的特殊字符为字面量。如：/\\d/ 匹配一个数字，/a\\*/ 匹配‘a*’ ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 匹配输入的开始。如：/^a/匹配以a开始的字符 $ 匹配输入的结束。如：/b$/匹配以b结束的字符 * 匹配前一个表达式0次或多次，等价于{0,}。如：/cd*/匹配‘abcdef’中的‘cd’，匹配‘abcef’中的‘c’，但不会匹配‘abdef’中的任何字符。 + 匹配前一个表达式1次或多次，等价于{1,}。如：/a+/匹配了在 ‘candy’ 中的 ‘a’，和在 ‘caaaaaaandy’ 中所有的 ‘a’。 ? 匹配前一个表达式0次或1次，等价于 {0,1}。如：/e?le?/ 匹配 ‘angel’ 中的 ‘el’，和 ‘angle’ 中的 ‘le’ 以及‘oslo’ 中的‘l’。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪的（匹配尽量少的字符），如：/\\d+?/ 匹配‘123abc’中的‘1’ . 匹配除换行符之外的任何单个字符。如：/.n/将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 (x) 匹配 ‘x’ 并且记住匹配项。如：/(foo) (bar) \\1 \\2/将会匹配 “foo bar foo bar” 并记住前2个单词。 (?:x) 匹配 ‘x’ 但不记住匹配项。如：/(?:foo){1,2}/，如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。 x(?=y) 匹配 ‘x’ 仅仅当 ‘x’ 后面跟着 ‘y’。如：/Jack(?=Sprat)/会匹配到’Jack’仅仅当它后面跟着 ‘Sprat’。但是‘Sprat’不是匹配结果的一部分。 x(?!y) 匹配 ‘x’ 仅仅当 ‘x’ 后面不跟着 ‘y’。如：/\\d+(?!.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’但是不是‘3.141’。 {n} 匹配了前面一个字符刚好发生了n次。如：/a{2}/不会匹配“candy”中的 ‘a’,但是会匹配“caandy”中所有的a，以及“caaandy”中的前两个 ‘a’。 {n,m} 匹配匹配前面的字符至少n次，最多m次。如：/a{1, 3}/ 并不匹配“cndy”中的任意字符，匹配“candy”中得a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。 [xyz] 匹配方括号的中任意字符，包括转义序列，可以使用破折号（-）来指定一个字符范围。如：[abcd] 和[a-d]是一样的。他们都匹配”brisket”中得‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/都匹配“test.i.ng”中得所有字符。 [^xyz] 匹配任何没有包含在方括号中的字符。如：[^abc] 和 [^a-c] 是一样的。他们匹配”brisket”中得‘r’，也匹配“chop”中的‘h’。 [\\b] 匹配一个退格(U+0008)。 元字符 字符 含义 \\b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 匹配一个词的边界。如：/\\bm/匹配“moon”中的‘m’；/oo\\b/并不匹配 “moon”中的 ‘oo’，/oon\\b/匹配 “moon”中的 ‘oon’ \\B 匹配一个非单词边界，一个字符串的开始和结尾都被认为是非单词。如：/\\B../匹配 “noonday” 中得 ‘oo’, 而/y\\B./匹配 “possibly yesterday”中得 ‘ye’ \\cX 当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。如：/\\cM/ 匹配字符串中的 control-M (U+000D)。 \\d 匹配一个数字，等价于[0-9]。如：/\\d/ 或者 /[0-9]/ 匹配 “B2 is the suite number.”中的 ‘2’。 \\D 匹配一个非数字字符，等价于[^0-9]。如：/\\D/ 或者 /[^0-9]/ 匹配 “B2 is the suite number.”中的 ‘B’。 \\f 匹配一个换页符。 \\n 匹配一个换行符。 \\r 匹配一个回车符。 \\s 匹配一个空白字符，包括空格、制表符、换页符和换行符。如：/\\s\\w*/ 匹配 “foo bar.”中的 ‘ bar’。 \\S 匹配一个非空白字符。如：/\\S\\w*/ 匹配 “foo bar.”中的 ‘foo’。 \\w 匹配一个单字字符。如：/\\w/ 匹配 “apple,” 中的 ‘a’， “$5.28,” 中的 ‘5’ 和 “3D.” 中的 ‘3’。 \\W 匹配一个非单字字符。如：/\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。 \\n 当 n 是一个正整数，一个返回引用到最后一个与有n插入的正则表达式(counting left parentheses)匹配的副字符串。如：/apple(,)\\sorange\\1/ 匹配 “apple, orange, cherry, peach.”中的 ‘apple, orange,’ 。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Node实现文件系统操作：导出Excel","slug":"Node-export-excel","date":"2018-02-08T08:38:34.000Z","updated":"2018-04-10T05:50:14.237Z","comments":true,"path":"2018/02/08/Node-export-excel/","link":"","permalink":"http://yoursite.com/2018/02/08/Node-export-excel/","excerpt":"依赖模块以及第三方包node中，文件 I/O 是对标准 POSIX 函数的简单封装，通过fs模块可实现对文件系统的操作；\b因为要操作报表，这里我们引入三方包node-xlsx API说明fs模块提供了fs.writeFile(file, data[, options], callback)和fs.writeFileSync(file, data[, options])两个api实现对文件的写入，由方法名可知分别是异步和同步的实现 fs.writeFile(file, data[, options], callback) file &lt;string&gt; | &lt;Buffer&gt; | &lt;integer&gt; 文件名或文件描述符 data &lt;string&gt; | &lt;Buffer&gt; | &lt;Uint8Array&gt; options &lt;Object&gt; | &lt;string&gt; callback &lt;Function&gt; 异步地写入数据到文件，如果文件已经存在，则替代文件。 data 可以是一个字符串或一个 buffer。任何指定的文件描述符必须支持写入,多次对同一文件使用 fs.writeFile 且不等待回调，是不安全的。 对于这种情况，强烈推荐使用 fs.createWriteStream。fs.writeFileSync()为fs.writeFile() 的同步版本，返回 undefined。","text":"依赖模块以及第三方包node中，文件 I/O 是对标准 POSIX 函数的简单封装，通过fs模块可实现对文件系统的操作；\b因为要操作报表，这里我们引入三方包node-xlsx API说明fs模块提供了fs.writeFile(file, data[, options], callback)和fs.writeFileSync(file, data[, options])两个api实现对文件的写入，由方法名可知分别是异步和同步的实现 fs.writeFile(file, data[, options], callback) file &lt;string&gt; | &lt;Buffer&gt; | &lt;integer&gt; 文件名或文件描述符 data &lt;string&gt; | &lt;Buffer&gt; | &lt;Uint8Array&gt; options &lt;Object&gt; | &lt;string&gt; callback &lt;Function&gt; 异步地写入数据到文件，如果文件已经存在，则替代文件。 data 可以是一个字符串或一个 buffer。任何指定的文件描述符必须支持写入,多次对同一文件使用 fs.writeFile 且不等待回调，是不安全的。 对于这种情况，强烈推荐使用 fs.createWriteStream。fs.writeFileSync()为fs.writeFile() 的同步版本，返回 undefined。 需求实现简单了解了API之后，我们就可以实现写入文件数据的功能了，但要生成Excel文件，还需借助三方包node-xlsx。至于该三方包的详细API，请移步官方xlsx查看，下面看代码示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const AdvertisedPrice = require('./api/consultant-system/config/advertised-price');const xlsx = require('node-xlsx')const fs = require('fs')//表格需要导出的内容const excelHeaders = &#123; detailHeader: [ '类目id', '类目名称', '类目价格' ], detailHeaderAlias: [ 'key', 'keyName', 'value' ], detailHeaderWidth: &#123; '!cols': [ &#123;wch: 15&#125;, &#123;wch: 55&#125;, &#123;wch: 15&#125; ] &#125;&#125;/* * 数据转换 * */function transformData(arr, excelHeader, excelHeaderAlias, res) &#123; if (!Array.isArray(arr)) &#123; res.send('数据格式不对') &#125; const finalArr = [] const hAlias = excelHeaders[excelHeaderAlias] arr.forEach((curVal, index) =&gt; &#123; finalArr[index] = [] hAlias.forEach(val =&gt; &#123; if (val === 'key') &#123; finalArr[index].push((curVal)[val].split('.')[3]) &#125; else &#123; finalArr[index].push((curVal)[val]) &#125; &#125;) &#125;) finalArr.unshift(excelHeaders[excelHeader]) return finalArr&#125;UA.onGet('/api/consultant/config/advertised-price/export', (req, res, next) =&gt; &#123; const qo = req.query let queryData = &#123; groupName: qo.groupName, originData: qo.originData || [] &#125; new AdvertisedPrice(queryData).getAllAdvertisedPrice().then(rs =&gt; &#123; const tempData = rs.data if (tempData) &#123; const data = transformData(tempData, qo.header, qo.headerAlias, res) const buffer = xlsx.build([&#123;data: data, name: qo.filename&#125;], excelHeaders[`$&#123;qo.header&#125;Width`]) try &#123; fs.writeFileSync(`$&#123;qo.filename&#125;.xlsx`, buffer, 'binary') res.download(`$&#123;qo.filename&#125;.xlsx`, err =&gt; &#123; if (err) &#123; res.send(`download price excel failed---&gt;$&#123;err.toString()&#125;`) next() &#125; else &#123; res.send('download price excel successful') &#125; &#125;) &#125; catch (error) &#123; console.log(`download price excel failed---&gt;$&#123;error.toString()&#125;`) &#125; finally &#123; fs.unlink(`$&#123;qo.filename&#125;.xlsx`) &#125; &#125; else &#123; res.send(&#123;msg: 'download price excel failed: has no price config data'&#125;) &#125; &#125;).catch(err =&gt; &#123; res.send(&#123;msg: `download price excel failed---&gt;$&#123;err&#125;`&#125;) &#125;)&#125;) 前端层请求需要注意的是：因为文件是以流的形式传输，而ajax请求的返回值类型是json、text、HTML、xml等类型，所以ajax是无法实现文件下载的。但用ajax仍然可以获得文件的内容，该文件将被保留在内存中，无法将文件保存到磁盘。这是因为JavaScript无法和磁盘进行交互，否则这会是一个严重的安全问题，js无法调用到浏览器的下载处理机制和程序，会被浏览器阻塞。实现文件下载可以用&lt;a&gt;标签或者location.href实现","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"Linux学习笔记一：文件权限与目录配置","slug":"Linux-file-directory-config","date":"2018-01-17T13:37:47.000Z","updated":"2018-04-18T14:37:38.000Z","comments":true,"path":"2018/01/17/Linux-file-directory-config/","link":"","permalink":"http://yoursite.com/2018/01/17/Linux-file-directory-config/","excerpt":"文件属性u start –&gt; permission deny ？老铁，肯定是权限不够 ！虽然你sudo u start了，但我还是想从Linux的文件属性下嘴，和大家一起学习学习Linux的文件权限。话不多说，首先我们执行一下ls -l（先别问为什么，我也不知道），看到以下结果： ls是list的意思，该命令显示文件的文件名与相关属性，参数-l表示以单列格式输出文件的相关信息。","text":"文件属性u start –&gt; permission deny ？老铁，肯定是权限不够 ！虽然你sudo u start了，但我还是想从Linux的文件属性下嘴，和大家一起学习学习Linux的文件权限。话不多说，首先我们执行一下ls -l（先别问为什么，我也不知道），看到以下结果： ls是list的意思，该命令显示文件的文件名与相关属性，参数-l表示以单列格式输出文件的相关信息。 第一列：代表该文件的类型与权限可以看到，第一列一共有10个字符，其中第一个字符代表该文件的类型 [d]：目录 [-]：文件 [l]：连接文件（linkfile，类似于Windows下的快捷方式） [b]：设备文件里面的可供存储的接口设备 [c]：设备文件里面的串行端口设备，例如键盘、鼠标等 接下来的字符中，以3个为一组，且均为”rwx的3个参数的组合。r代表可读(read)，w代表可写(write)，x代表可执行(execute)，这3个\b权限的位置不会改变，如果没有权限，则显示为“-”： 第一组：[文件拥有者可具备\b的权限]，以“Tomorrow.itermcolors”为例，该文件所有者可以读写，但不可执行 第二组：[加入该用户组的账号对此文件的权限] 第三组：[其他非本用户组且非拥有者的账号对此文件的权限] 第二列：表示有多少文件名连接到该节点（i-node）第三列：代表该文件（目录）的“所有者账号” 第四列：代表该文件的所属用户组Linux系统下，用户账号会附属于一个或者多个用户组中。比如用户User1、User2、USer3\b均属于staff这个用户组，如上图所示“Creative Cloud Files”所属的用户组为staff，该文件的权限为drwxrwxr-x,则用户USer1、USer2、USer3对该文件都具有可读、可写、可执行的权限，但非staff用户组的其他用户对该文件只具备可读、可执行的权限 第五列：代表该文件的容量大小，默认单位为B第六列：代表该文件的创建日期或最近修改日期第七列：代表该文件的名称 修改文件属性与权限现在我们已经大概了解到了文件的属性与权限，那么如何修改一个文件的属性与权限呢？其实一个文件的属性与权限有很多，我们先\b了解几个常用于用户组、所有者、其他各种权限的修改命令： chgrp：改变文件所属用户组 chown：改变文件所有者 chmod：改变文件权限 改变所属用户组：chgrp（change group） 要被改变的组名必须要在/etc/group文件内 存在才行，否则会执行失败 命令格式为：chgrp [-R] dirname/filename（-R表示进行递归的持续更改，即连同子目录下的所有文件都更新为这个用户组） 改变文件所有者：chown（change owner） 用户必须是已经存在于系统中的账号（/etc/passwd这个文件中有记录的用户） chown [-R] 账号名称 文件或目录 chown [-R] 账号名称:组名 文件或目录 改变文件权限：chmod（change mode）文件权限的改变使用的是chmod指令，设定方法有两种：数字和符号 1、数字类型改变文件权限Linux文件的基本权限有9个，分别是owner/group/others三种身份各有自己的read/write/execute权限，如之前看到的文件权限：[-rwxr-xr--]，这9个权限是3个3个一组。我们可以用数字来代表各个权限 r:4 w:2 x:1 每种身份各自的3个权限累加，上面的例子中： owner = rwx = 4+2+1 = 7 group = r-x = 4+0+1 = 5 others = r– = 4+0+0 = 4 所以，如果要将上述例子中权限为[-rwxr-xr--]的权限改为[-rwxrwxrwx]，那么对应的权限分数就是[4+2+1][4+2+1][4+2+1]=777，下面我们一起来看下chmod指令的实际\b应用吧 2、符号类型改变文件权限上面有讲到，文件的权限有9个，分别是user(3个：rwx)、group(3个：rwx)、others(3个：rwx)，由u、g、o分别代表3中身份 来实际操作一下吧！假如我们要设定一个文件的\b权限为drwxr--r--，则u=rwx,go=r 需要特别注意的是：u=rwx,go=r是连在一起的，中间没有任何空格符！ Linux目录配置Linux目录配置标准–FHS目前大多数Linux系统都遵循FHS规范，FHS依据“文件系统使用的频率以及是否允许文件系统使用者随意更改”而将目录定义成四种交互作用的形态，大概像下面这样：上表中的目录是一些代表性的目录，这些目录代表的四个类型的意义如下： 可分享的：可以分享给其他系统挂载使用（例如执行文件、用户的邮件数据等） 不可分享的：个人机器上运行的装置文件或者与程序相关的socket文件（仅与自身机器有关） 不变的：不会经常变动的数据（例如函式库、文件说明文件、主机服务配置文件等） 可变动的：经常改变的数据（例如登录文件、一般用户可自行收受的新闻组等） 事实上，FHS针对目录树结构仅定义出三层目录底下应该放置什么数据，分别是： /(root，根目录)：与开机系统有关 /usr(unix software resource)：与软件安装/执行有关 /var(variable)：与系统运作过程有关 目录树（directory tree）因为所有文件和目录都是由根目录开始，再一个一个分支下来，有点像树枝状，因此将这种目录配置方式称为“目录树”。它的主要特征有： 目录树的起点为根目录（/， root） 每一个目录不止能使用本地段的文件系统，也可以使用网络上的文件系统。例如可以利用Network File System（NFS）服务器挂载特定目录 每一个文件在此目录树种的文件名（包含完整路径）都是独一无二的 如果将整个目录树以图示的方法来显示，并将较为重要的文件数据列出来的话，目录树架构图大概如图所示： 绝对路径与相对路径根据文件名写法的不同，可以将路径（path）定义为相对路径（relative）与绝对路径（absolute），这两种文件名/路径的写法依据如下： 绝对路径：由根目录（/）开始写起，如 /etc/hosts 相对路径：相对于目前路径的文件名写法。只要不是/开头的写法都属于相对路径写法，如../Guest/ 思考：如果你当前在/home目录下，想进入/var/log目录，指令可以怎么写呢？如上述，绝对路径以根目录开始，相对路径是以“当前所在路径的相对位置”来表示的，那么可以这样写： cd ../var/log cd /var/log ./代表当前目录，../代表上一层目录，使用pwd指令可以查看当前路径的绝对路径 结束语至此，相信大家对Linux的文件属性与目录结构已经有了初步的认识。感谢大家对本文的阅读，下一次，我将与大家一起学习Linux文件与目录管理的相关知识，敬请关注。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"CSS+图片简单实现五角星推荐指数","slug":"css-pentagram","date":"2018-01-10T12:26:38.000Z","updated":"2018-04-10T06:22:32.408Z","comments":true,"path":"2018/01/10/css-pentagram/","link":"","permalink":"http://yoursite.com/2018/01/10/css-pentagram/","excerpt":"实现原理一张灰色五角星背景图至于底层，一张评分的亮色五角星图至于上层，利用CSS clip属性裁剪亮色五角星长度，实现推荐指数 HTML12345&lt;span class=\"recommended\"&gt; 推荐指数 &lt;i class=\"stars\"&gt;&lt;i class=\"inner\" :style=\"&#123;clip: rect&#125;\"&gt;&lt;/i&gt;&lt;/i&gt; &lt;i&gt;&#123;&#123;baseInfo.recommended&#125;&#125;&lt;/i&gt;&lt;/span&gt; CSS12345678910111213141516171819202122.stars &#123; display: inline-block; vertical-align: top; margin-top: 2px; margin-left: 5px; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars.png\"); background-size: contain; .inner &#123; display: inline-block; vertical-align: top; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars-active.png\"); background-size: contain; position: absolute; /*clip: rect(0 73px 13px 0);*/ &#125;&#125;","text":"实现原理一张灰色五角星背景图至于底层，一张评分的亮色五角星图至于上层，利用CSS clip属性裁剪亮色五角星长度，实现推荐指数 HTML12345&lt;span class=\"recommended\"&gt; 推荐指数 &lt;i class=\"stars\"&gt;&lt;i class=\"inner\" :style=\"&#123;clip: rect&#125;\"&gt;&lt;/i&gt;&lt;/i&gt; &lt;i&gt;&#123;&#123;baseInfo.recommended&#125;&#125;&lt;/i&gt;&lt;/span&gt; CSS12345678910111213141516171819202122.stars &#123; display: inline-block; vertical-align: top; margin-top: 2px; margin-left: 5px; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars.png\"); background-size: contain; .inner &#123; display: inline-block; vertical-align: top; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars-active.png\"); background-size: contain; position: absolute; /*clip: rect(0 73px 13px 0);*/ &#125;&#125; JavaScript1self.rect = 'rect(0,' + (self.baseInfo.recommended / 5) * 80 + 'px, 13px, 0)' 效果","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"基于NodeJs防御csrf攻击","slug":"NodeJs-csrf","date":"2018-01-04T13:32:40.000Z","updated":"2018-04-10T05:46:34.609Z","comments":true,"path":"2018/01/04/NodeJs-csrf/","link":"","permalink":"http://yoursite.com/2018/01/04/NodeJs-csrf/","excerpt":"CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行 NodeJs下防御CSRF攻击思路验证 HTTP Referer 字段 HTTP 头中有一个 Referer 字段，它记录了该 HTTP 请求的来源地址，对该地址进行判断，如果同源则通过验证，否则拒绝请求123456789101112refererCheck(req, res, next)&#123; let referer = req.headers.referer; let refererHost = (referer &amp;&amp; referer.replace(/https?:\\/\\//ig, \"\").split(\"/\")[0]) || \"\"; let reg = new RegExp(\"\\\\.\" + app.config.baseURI.replace(/\\./g, \"\\\\.\") + \"$\"; if(!reg.test(refererHost))&#123; next(); &#125;&#125;app.get('/api/test', utils.refererCheck, (req, res, next) =&gt; &#123; // dosomething return xxx;&#125;); 以上，当请求/api/test时，站点A会劫持User(c)的请求并判断请求referer来源，如果发现来源于站点，则会拒绝请求","text":"CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行 NodeJs下防御CSRF攻击思路验证 HTTP Referer 字段 HTTP 头中有一个 Referer 字段，它记录了该 HTTP 请求的来源地址，对该地址进行判断，如果同源则通过验证，否则拒绝请求123456789101112refererCheck(req, res, next)&#123; let referer = req.headers.referer; let refererHost = (referer &amp;&amp; referer.replace(/https?:\\/\\//ig, \"\").split(\"/\")[0]) || \"\"; let reg = new RegExp(\"\\\\.\" + app.config.baseURI.replace(/\\./g, \"\\\\.\") + \"$\"; if(!reg.test(refererHost))&#123; next(); &#125;&#125;app.get('/api/test', utils.refererCheck, (req, res, next) =&gt; &#123; // dosomething return xxx;&#125;); 以上，当请求/api/test时，站点A会劫持User(c)的请求并判断请求referer来源，如果发现来源于站点，则会拒绝请求 添加 token 并验证在服务器上生成一个token, web端发起的请求都带上token这个参数, 请求中的token与服务端的token不一致,则抛出错误.1、引入npm包csurf12const csrf = require('csurf');const csrfProtection = csrf(&#123;cookie: true&#125;); 2、校验请求1234app.get('/form', csrfProtection, function(req, res) &#123; // pass the csrfToken to the view res.render('send', &#123; csrfToken: req.csrfToken() &#125;)&#125;) 关于csurf模块首先看下源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function csurf (options) &#123; var opts = options || &#123;&#125; // get cookie options var cookie = getCookieOptions(opts.cookie) // get session options var sessionKey = opts.sessionKey || 'session' // get value getter var value = opts.value || defaultValue // token repo var tokens = new Tokens(opts) // ignored methods var ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods if (!Array.isArray(ignoreMethods)) &#123; throw new TypeError('option ignoreMethods must be an array') &#125; // generate lookup var ignoreMethod = getIgnoredMethods(ignoreMethods) return function csrf (req, res, next) &#123; // validate the configuration against request if (!verifyConfiguration(req, sessionKey, cookie)) &#123; return next(new Error('misconfigured csrf')) &#125; // get the secret from the request var secret = getSecret(req, sessionKey, cookie) var token // lazy-load token getter req.csrfToken = function csrfToken () &#123; var sec = !cookie ? getSecret(req, sessionKey, cookie) : secret // use cached token if secret has not changed if (token &amp;&amp; sec === secret) &#123; return token &#125; // generate &amp; set new secret if (sec === undefined) &#123; sec = tokens.secretSync() setSecret(req, res, sessionKey, sec, cookie) &#125; // update changed secret secret = sec // create new token token = tokens.create(secret) return token &#125; // generate &amp; set secret if (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie) &#125; // verify the incoming token if (!ignoreMethod[req.method] &amp;&amp; !tokens.verify(secret, value(req))) &#123; return next(createError(403, 'invalid csrf token', &#123; code: 'EBADCSRFTOKEN' &#125;)) &#125; next() &#125;&#125; 服务端如何生产成token, token存储的位置当csurf()方法被执行时，会为req添加一个方法csrfToken，该方法生成一个token, 并保存session中12345// generate &amp; set secretif (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie)&#125; 服务端校验的token, 可能来自哪里12345678function defaultValue (req) &#123; return (req.body &amp;&amp; req.body._csrf) || (req.query &amp;&amp; req.query._csrf) || (req.headers['csrf-token']) || (req.headers['xsrf-token']) || (req.headers['x-csrf-token']) || (req.headers['x-xsrf-token'])&#125; 从代码上，如果csurlf初始化时没带任何参数，则校验的token使用使用默认的值，默认的token可能来自req.body, req.query, req.header 哪些请求不校验token1234// ignored methodsvar ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods 如果csurlf初始化时没带任何参数，则 get head option方法不做校验 参考文献1、npm csurf","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"浅谈ES6新特性之promise篇","slug":"ES6-promise","date":"2018-01-03T14:03:30.000Z","updated":"2018-04-10T07:09:02.000Z","comments":true,"path":"2018/01/03/ES6-promise/","link":"","permalink":"http://yoursite.com/2018/01/03/ES6-promise/","excerpt":"JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。","text":"JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。 promise对象 Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 一个promise有以下几个状态： pending: 初始状态，成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 Promise方法首先附上一段代码，以此来理解Promise.all()、Promise.race()、Promise.resolve()、Promise.reject()方法12345678910111213141516171819202122232425262728293031323334353637383940let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve('promise1 OK')&#125;)let promise2 = new Promise((resolve, reject) =&gt; &#123; resolve('promise2 OK')&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; reject('promise3 fail')&#125;)Promise.all([promise1, promise2]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;)Promise.all([promise1, promise3]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;)Promise.race([promise1, promise2]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise1, promise3]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise3, promise1]).then(res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行失败：$&#123;res&#125;`)&#125;); 由以上代码及运行结果可见 Promise.all(iterable)Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例：var p = Promise.all([promise1, promise2]);该方法接受一个数组作为参数，p的状态由promise1、promise2决定，分两种情况： 只有promise1、promise2的状态都变成fulfilled，p的状态才会变成fulfilled，此时promise1、promise2的返回值组成一个数组，传递给p的回调函数。 只要promise1、promise2之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.race(iterable)该方法同Promise.all()一样的是：也用于将多个Promise实例包装成一个新的Promise实例：var p = Promise.race([promise1, promise3]); || var p = Promise.race([promise1, promise3]);不同的是：当promise1、promise3里的任意一个promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.resolve(value)返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 Promise.reject(reason)返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 Promise原型Promise.prototype.constructor返回被创建的实例函数. 默认为 Promise 函数. Promise.prototype.then(onFulfilled, onRejected)添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. Promise.prototype.catch(onRejected)添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果. 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Vue学习笔记之父子组件通信","slug":"Vue-component-communication","date":"2017-12-27T13:29:29.000Z","updated":"2018-04-10T06:21:42.907Z","comments":true,"path":"2017/12/27/Vue-component-communication/","link":"","permalink":"http://yoursite.com/2017/12/27/Vue-component-communication/","excerpt":"定义父子组件HTML12345678&lt;div class=\"hello\"&gt; &lt;Welcome :message=\"msg\" @contact=\"comFromChildren\"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type=\"text\" name=\"username\" v-model=\"userName\"&gt; &lt;br&gt; &lt;input type=\"text\" name=\"age\" v-model=\"age\"&gt; &lt;br&gt; &lt;a href=\"javascript:;\" @click=\"addUser\"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125;","text":"定义父子组件HTML12345678&lt;div class=\"hello\"&gt; &lt;Welcome :message=\"msg\" @contact=\"comFromChildren\"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type=\"text\" name=\"username\" v-model=\"userName\"&gt; &lt;br&gt; &lt;input type=\"text\" name=\"age\" v-model=\"age\"&gt; &lt;br&gt; &lt;a href=\"javascript:;\" @click=\"addUser\"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125; 定义子组件HTML1234&lt;template&gt; &lt;!--接受父组件传来的消息--&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/template&gt; JavaScript1234567export default &#123; name: \"welcome\", props: ['message'], created() &#123; this.$emit('contact'); //通知父组件 &#125;&#125; 子组件接收父组件数据","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"webpack部署过程中遇到的问题","slug":"webpack-config","date":"2017-12-05T09:39:11.000Z","updated":"2018-04-10T06:20:58.000Z","comments":true,"path":"2017/12/05/webpack-config/","link":"","permalink":"http://yoursite.com/2017/12/05/webpack-config/","excerpt":"问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼……","text":"问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼…… 暂时解决方案从其他同事处拷贝了安装好的依赖包，放到项目代码中依然有问题，because……同事的操作系统是Windows，所以拷贝之后，依然有些包不能用：根据报错提示命令执行，终于解决： 暂时留坑在这里，等调试完项目之后再来回顾该问题 /(ㄒoㄒ)/~~ 更新终于想起还有这个坑没填……依赖包安装不上完全是因为那些包都是私有包的问题……","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"MacOS 下配置Apache本地域名服务器","slug":"MacOS-Apache","date":"2017-12-01T03:17:29.000Z","updated":"2018-04-10T06:20:35.000Z","comments":true,"path":"2017/12/01/MacOS-Apache/","link":"","permalink":"http://yoursite.com/2017/12/01/MacOS-Apache/","excerpt":"需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件","text":"需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件 开启Apache虚拟主机功能vi /etc/apache2/httpd.conf打开Apache配置文件，找到Include /private/etc/apache2/extra/httpd-vhosts.conf，放开注释，开启虚拟主机功能: vi /etc/apache2/extra/httpd-vhosts.conf配置虚拟主机： 启动Apache服务，域名访问项目sudo apachectl start，好了，现在可以通过域名访问项目资源了：","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/服务器/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"http://yoursite.com/tags/Apache/"}]},{"title":"线上问题日志定位手段","slug":"online-problem-logs","date":"2017-11-30T03:50:30.000Z","updated":"2018-04-10T06:31:37.000Z","comments":true,"path":"2017/11/30/online-problem-logs/","link":"","permalink":"http://yoursite.com/2017/11/30/online-problem-logs/","excerpt":"背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径：","text":"背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径： 找到日志之后，就可以对指定级别的日志文件进行实时监控啦。一般发生问题时该监控error日志，本文以info日志为例： 然后进入软件系统进行相应操作，即可看见操作产生的对应日志了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux下查找包含指定内容的文件","slug":"Linux-find","date":"2017-11-29T16:00:00.000Z","updated":"2018-04-10T07:07:59.000Z","comments":true,"path":"2017/11/30/Linux-find/","link":"","permalink":"http://yoursite.com/2017/11/30/Linux-find/","excerpt":"需求背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图： 嗯，可以准备下手修改样式了！but……这个样式表在哪里？翻遍了文件夹都没找到对应的这个main.css啊！没关系，接下来该我们本文的主角出场了","text":"需求背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图： 嗯，可以准备下手修改样式了！but……这个样式表在哪里？翻遍了文件夹都没找到对应的这个main.css啊！没关系，接下来该我们本文的主角出场了 find命令以本人对Linux模糊的记忆，搜索到了强悍的find命令find .|xargs grep -ri &quot;xxx&quot;：其中|表示将上一次的find指令执行得到的结果交由下一个指令继续执行。执行该完整指令，good，找到了一大堆文件：修改样式，上传，查看blog样式，perfect，手工！ 小插曲为了省去本文的标题、分类、标签等一系列配置，我打算直接复用上一篇文章的配置。这样的话我首先用vim命令新建了该文章的文件Linux.md，然后cat xx.md &gt; Linux.md把xx文件的内容复制到了该文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}