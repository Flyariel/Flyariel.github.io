{"meta":{"title":"Ariel's Blog","subtitle":"我想在那里最蓝的大海扬帆 , 绝不管自己能不能回还","description":"沉迷卡农无法自拔","author":"Ariel","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2017-05-21T02:35:24.000Z","updated":"2017-05-26T10:36:07.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2017-05-21T02:49:54.000Z","updated":"2017-05-21T02:50:33.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-05-21T02:32:55.000Z","updated":"2017-05-21T02:34:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于NodeJs防御csrf攻击","slug":"基于NodeJs防止csrf攻击","date":"2018-01-04T13:32:40.000Z","updated":"2018-01-05T14:46:20.000Z","comments":true,"path":"2018/01/04/基于NodeJs防止csrf攻击/","link":"","permalink":"http://yoursite.com/2018/01/04/基于NodeJs防止csrf攻击/","excerpt":"CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行","text":"CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行 NodeJs下防御CSRF攻击思路验证 HTTP Referer 字段 HTTP 头中有一个 Referer 字段，它记录了该 HTTP 请求的来源地址，对该地址进行判断，如果同源则通过验证，否则拒绝请求123456789101112refererCheck(req, res, next)&#123; let referer = req.headers.referer; let refererHost = (referer &amp;&amp; referer.replace(/https?:\\/\\//ig, \"\").split(\"/\")[0]) || \"\"; let reg = new RegExp(\"\\\\.\" + app.config.baseURI.replace(/\\./g, \"\\\\.\") + \"$\"; if(!reg.test(refererHost))&#123; next(); &#125;&#125;app.get('/api/test', utils.refererCheck, (req, res, next) =&gt; &#123; // dosomething return xxx;&#125;); 以上，当请求/api/test时，站点A会劫持User(c)的请求并判断请求referer来源，如果发现来源于站点，则会拒绝请求 添加 token 并验证在服务器上生成一个token, web端发起的请求都带上token这个参数, 请求中的token与服务端的token不一致,则抛出错误.1、引入npm包csurf12const csrf = require('csurf');const csrfProtection = csrf(&#123;cookie: true&#125;); 2、校验请求1234app.get('/form', csrfProtection, function(req, res) &#123; // pass the csrfToken to the view res.render('send', &#123; csrfToken: req.csrfToken() &#125;)&#125;) 关于csurf模块首先看下源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function csurf (options) &#123; var opts = options || &#123;&#125; // get cookie options var cookie = getCookieOptions(opts.cookie) // get session options var sessionKey = opts.sessionKey || 'session' // get value getter var value = opts.value || defaultValue // token repo var tokens = new Tokens(opts) // ignored methods var ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods if (!Array.isArray(ignoreMethods)) &#123; throw new TypeError('option ignoreMethods must be an array') &#125; // generate lookup var ignoreMethod = getIgnoredMethods(ignoreMethods) return function csrf (req, res, next) &#123; // validate the configuration against request if (!verifyConfiguration(req, sessionKey, cookie)) &#123; return next(new Error('misconfigured csrf')) &#125; // get the secret from the request var secret = getSecret(req, sessionKey, cookie) var token // lazy-load token getter req.csrfToken = function csrfToken () &#123; var sec = !cookie ? getSecret(req, sessionKey, cookie) : secret // use cached token if secret has not changed if (token &amp;&amp; sec === secret) &#123; return token &#125; // generate &amp; set new secret if (sec === undefined) &#123; sec = tokens.secretSync() setSecret(req, res, sessionKey, sec, cookie) &#125; // update changed secret secret = sec // create new token token = tokens.create(secret) return token &#125; // generate &amp; set secret if (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie) &#125; // verify the incoming token if (!ignoreMethod[req.method] &amp;&amp; !tokens.verify(secret, value(req))) &#123; return next(createError(403, 'invalid csrf token', &#123; code: 'EBADCSRFTOKEN' &#125;)) &#125; next() &#125;&#125; 服务端如何生产成token, token存储的位置当csurf()方法被执行时，会为req添加一个方法csrfToken，该方法生成一个token, 并保存session中12345// generate &amp; set secretif (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie)&#125; 服务端校验的token, 可能来自哪里12345678function defaultValue (req) &#123; return (req.body &amp;&amp; req.body._csrf) || (req.query &amp;&amp; req.query._csrf) || (req.headers['csrf-token']) || (req.headers['xsrf-token']) || (req.headers['x-csrf-token']) || (req.headers['x-xsrf-token'])&#125; 从代码上，如果csurlf初始化时没带任何参数，则校验的token使用使用默认的值，默认的token可能来自req.body, req.query, req.header 哪些请求不校验token1234// ignored methodsvar ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods 如果csurlf初始化时没带任何参数，则 get head option方法不做校验 参考文献1、npm csurf","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"浅谈ES6新特性之promise篇","slug":"深入理解ES6新特性之promise篇","date":"2018-01-03T14:03:30.000Z","updated":"2018-01-08T14:15:54.367Z","comments":true,"path":"2018/01/03/深入理解ES6新特性之promise篇/","link":"","permalink":"http://yoursite.com/2018/01/03/深入理解ES6新特性之promise篇/","excerpt":"JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。","text":"JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。 promise对象 Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 一个promise有以下几个状态： pending: 初始状态，成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 Promise方法首先附上一段代码，以此来理解Promise.all()、Promise.race()、Promise.resolve()、Promise.reject()方法12345678910111213141516171819202122232425262728293031323334353637383940let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve('promise1 OK')&#125;)let promise2 = new Promise((resolve, reject) =&gt; &#123; resolve('promise2 OK')&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; reject('promise3 fail')&#125;)Promise.all([promise1, promise2]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;)Promise.all([promise1, promise3]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;)Promise.race([promise1, promise2]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise1, promise3]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise3, promise1]).then(res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行失败：$&#123;res&#125;`)&#125;); 由以上代码及运行结果可见 Promise.all(iterable)Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例：var p = Promise.all([promise1, promise2]);该方法接受一个数组作为参数，p的状态由promise1、promise2决定，分两种情况： 只有promise1、promise2的状态都变成fulfilled，p的状态才会变成fulfilled，此时promise1、promise2的返回值组成一个数组，传递给p的回调函数。 只要promise1、promise2之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.race(iterable)该方法同Promise.all()一样的是：也用于将多个Promise实例包装成一个新的Promise实例：var p = Promise.race([promise1, promise3]); || var p = Promise.race([promise1, promise3]);不同的是：当promise1、promise3里的任意一个promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.resolve(value)返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 Promise.reject(reason)返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 Promise原型Promise.prototype.constructor返回被创建的实例函数. 默认为 Promise 函数. Promise.prototype.then(onFulfilled, onRejected)添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. Promise.prototype.catch(onRejected)添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果. 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Vue学习笔记之父子组件通信","slug":"Vue学习笔记之父子组件通信","date":"2017-12-27T13:29:29.000Z","updated":"2017-12-28T15:11:25.234Z","comments":true,"path":"2017/12/27/Vue学习笔记之父子组件通信/","link":"","permalink":"http://yoursite.com/2017/12/27/Vue学习笔记之父子组件通信/","excerpt":"定义父子组件HTML12345678&lt;div class=\"hello\"&gt; &lt;Welcome :message=\"msg\" @contact=\"comFromChildren\"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type=\"text\" name=\"username\" v-model=\"userName\"&gt; &lt;br&gt; &lt;input type=\"text\" name=\"age\" v-model=\"age\"&gt; &lt;br&gt; &lt;a href=\"javascript:;\" @click=\"addUser\"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125;","text":"定义父子组件HTML12345678&lt;div class=\"hello\"&gt; &lt;Welcome :message=\"msg\" @contact=\"comFromChildren\"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type=\"text\" name=\"username\" v-model=\"userName\"&gt; &lt;br&gt; &lt;input type=\"text\" name=\"age\" v-model=\"age\"&gt; &lt;br&gt; &lt;a href=\"javascript:;\" @click=\"addUser\"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125; 定义子组件HTML1234&lt;template&gt; &lt;!--接受父组件传来的消息--&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/template&gt; JavaScript1234567export default &#123; name: \"welcome\", props: ['message'], created() &#123; this.$emit('contact'); //通知父组件 &#125;&#125; 子组件接收父组件数据","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"webpack部署过程中遇到的问题","slug":"webpack-md","date":"2017-12-05T09:39:11.000Z","updated":"2017-12-18T12:27:12.184Z","comments":true,"path":"2017/12/05/webpack-md/","link":"","permalink":"http://yoursite.com/2017/12/05/webpack-md/","excerpt":"问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼……","text":"问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼…… 暂时解决方案从其他同事处拷贝了安装好的依赖包，放到项目代码中依然有问题，because……同事的操作系统是Windows，所以拷贝之后，依然有些包不能用：根据报错提示命令执行，终于解决： 暂时留坑在这里，等调试完项目之后再来回顾该问题 /(ㄒoㄒ)/~~","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"MacOS 下配置Apache本地域名服务器","slug":"MacOS-下配置Apache本地域名服务器","date":"2017-12-01T03:17:29.000Z","updated":"2017-12-01T05:56:14.005Z","comments":true,"path":"2017/12/01/MacOS-下配置Apache本地域名服务器/","link":"","permalink":"http://yoursite.com/2017/12/01/MacOS-下配置Apache本地域名服务器/","excerpt":"需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件","text":"需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件 开启Apache虚拟主机功能vi /etc/apache2/httpd.conf打开Apache配置文件，找到Include /private/etc/apache2/extra/httpd-vhosts.conf，放开注释，开启虚拟主机功能: vi /etc/apache2/extra/httpd-vhosts.conf配置虚拟主机： 启动Apache服务，域名访问项目sudo apachectl start，好了，现在可以通过域名访问项目资源了：","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/服务器/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"http://yoursite.com/tags/Apache/"}]},{"title":"线上问题日志定位手段","slug":"online-problem-logs","date":"2017-11-30T03:50:30.000Z","updated":"2017-12-04T10:41:38.391Z","comments":true,"path":"2017/11/30/online-problem-logs/","link":"","permalink":"http://yoursite.com/2017/11/30/online-problem-logs/","excerpt":"背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径：","text":"背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径： 找到日志之后，就可以对指定级别的日志文件进行实时监控啦。一般发生问题时该监控error日志，本文以info日志为例： 然后进入软件系统进行相应操作，即可看见操作产生的对应日志了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux下查找包含指定内容的文件","slug":"Linux","date":"2017-11-29T16:00:00.000Z","updated":"2017-12-04T10:39:46.564Z","comments":true,"path":"2017/11/30/Linux/","link":"","permalink":"http://yoursite.com/2017/11/30/Linux/","excerpt":"背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类|标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图：","text":"背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类|标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图： 嗯，可以准备下手修改样式了！but……这个样式表在哪里啊？翻遍了文件夹都没找到对应的这个main.css啊！没关系，接下来该我们本文的主角出场了 机智的find命令以本人对Linux模糊的记忆，搜索到了强悍的find命令find .|xargs grep -ri &quot;xxx&quot;：执行，good，找到了一大堆文件：修改样式，上传，查看blog样式，perfect，手工！ 小插曲 为了省去本文的标题、分类、标签等一系列配置，我打算直接复用上一篇文章的配置。这样的话我首先用vim命令新建了该文章的文件Linux下查找文件/内容之find命令.md，然后cat xx.md &gt; Linux下查找文件/内容之find命令.md把xx文件的内容复制到了该文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}