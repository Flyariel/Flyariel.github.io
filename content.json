{"meta":{"title":"Ariel's Blog","subtitle":"我想在那里最蓝的大海扬帆 , 绝不管自己能不能回还","description":"沉迷卡农无法自拔","author":"Ariel","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2017-05-21T02:49:54.000Z","updated":"2017-05-21T02:50:33.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-05-21T02:32:55.000Z","updated":"2017-05-21T02:34:32.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-05-21T02:35:24.000Z","updated":"2017-05-26T10:36:07.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"node实现文件系统操作：导出Excel","slug":"node实现文件系统操作：导出Excel","date":"2018-02-08T08:38:34.000Z","updated":"2018-02-08T08:39:20.000Z","comments":true,"path":"2018/02/08/node实现文件系统操作：导出Excel/","link":"","permalink":"http://yoursite.com/2018/02/08/node实现文件系统操作：导出Excel/","excerpt":"","text":"","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"Linux学习笔记一：文件权限与目录配置","slug":"Linux学习笔记一：文件权限与目录配置","date":"2018-01-17T13:37:47.000Z","updated":"2018-01-19T01:21:18.481Z","comments":true,"path":"2018/01/17/Linux学习笔记一：文件权限与目录配置/","link":"","permalink":"http://yoursite.com/2018/01/17/Linux学习笔记一：文件权限与目录配置/","excerpt":"文件属性u start –&gt; permission deny ？老铁，肯定是权限不够 ！虽然你sudo u start了，但我还是想从Linux的文件属性下嘴，和大家一起学习学习Linux的文件权限。话不多说，首先我们执行一下ls -l（先别问为什么，我也不知道），看到以下结果： ls是list的意思，该命令显示文件的文件名与相关属性，参数-l表示以单列格式输出文件的相关信息。","text":"文件属性u start –&gt; permission deny ？老铁，肯定是权限不够 ！虽然你sudo u start了，但我还是想从Linux的文件属性下嘴，和大家一起学习学习Linux的文件权限。话不多说，首先我们执行一下ls -l（先别问为什么，我也不知道），看到以下结果： ls是list的意思，该命令显示文件的文件名与相关属性，参数-l表示以单列格式输出文件的相关信息。 第一列：代表该文件的类型与权限可以看到，第一列一共有10个字符，其中第一个字符代表该文件的类型 [d]：目录 [-]：文件 [l]：连接文件（linkfile，类似于Windows下的快捷方式） [b]：设备文件里面的可供存储的接口设备 [c]：设备文件里面的串行端口设备，例如键盘、鼠标等 接下来的字符中，以3个为一组，且均为”rwx的3个参数的组合。r代表可读(read)，w代表可写(write)，x代表可执行(execute)，这3个\b权限的位置不会改变，如果没有权限，则显示为“-”： 第一组：[文件拥有者可具备\b的权限]，以“Tomorrow.itermcolors”为例，该文件所有者可以读写，但不可执行 第二组：[加入该用户组的账号对此文件的权限] 第三组：[其他非本用户组且非拥有者的账号对此文件的权限] 第二列：表示有多少文件名连接到该节点（i-node）第三列：代表该文件（目录）的“所有者账号” 第四列：代表该文件的所属用户组Linux系统下，用户账号会附属于一个或者多个用户组中。比如用户User1、User2、USer3\b均属于staff这个用户组，如上图所示“Creative Cloud Files”所属的用户组为staff，该文件的权限为drwxrwxr-x,则用户USer1、USer2、USer3对该文件都具有可读、可写、可执行的权限，但非staff用户组的其他用户对该文件只具备可读、可执行的权限 第五列：代表该文件的容量大小，默认单位为B第六列：代表该文件的创建日期或最近修改日期第七列：代表该文件的名称 修改文件属性与权限现在我们已经大概了解到了文件的属性与权限，那么如何修改一个文件的属性与权限呢？其实一个文件的属性与权限有很多，我们先\b了解几个常用于用户组、所有者、其他各种权限的修改命令： chgrp：改变文件所属用户组 chown：改变文件所有者 chmod：改变文件权限 改变所属用户组：chgrp（change group） 要被改变的组名必须要在/etc/group文件内 存在才行，否则会执行失败 命令格式为：chgrp [-R] dirname/filename（-R表示进行递归的持续更改，即连同子目录下的所有文件都更新为这个用户组） 改变文件所有者：chown（change owner） 用户必须是已经存在于系统中的账号（/etc/passwd这个文件中有记录的用户） chown [-R] 账号名称 文件或目录 chown [-R] 账号名称:组名 文件或目录 改变文件权限：chmod（change mode）文件权限的改变使用的是chmod指令，设定方法有两种：数字和符号 1、数字类型改变文件权限Linux文件的基本权限有9个，分别是owner/group/others三种身份各有自己的read/write/execute权限，如之前看到的文件权限：[-rwxr-xr--]，这9个权限是3个3个一组。我们可以用数字来代表各个权限 r:4 w:2 x:1 每种身份各自的3个权限累加，上面的例子中： owner = rwx = 4+2+1 = 7 group = r-x = 4+0+1 = 5 others = r– = 4+0+0 = 4 所以，如果要将上述例子中权限为[-rwxr-xr--]的权限改为[-rwxrwxrwx]，那么对应的权限分数就是[4+2+1][4+2+1][4+2+1]=777，下面我们一起来看下chmod指令的实际\b应用吧 2、符号类型改变文件权限上面有讲到，文件的权限有9个，分别是user(3个：rwx)、group(3个：rwx)、others(3个：rwx)，由u、g、o分别代表3中身份 来实际操作一下吧！假如我们要设定一个文件的\b权限为drwxr--r--，则u=rwx,go=r 需要特别注意的是：u=rwx,go=r是连在一起的，中间没有任何空格符！ Linux目录配置Linux目录配置标准–FHS目前大多数Linux系统都遵循FHS规范，FHS依据“文件系统使用的频率以及是否允许文件系统使用者随意更改”而将目录定义成四种交互作用的形态，大概像下面这样：上表中的目录是一些代表性的目录，这些目录代表的四个类型的意义如下： 可分享的：可以分享给其他系统挂载使用（例如执行文件、用户的邮件数据等） 不可分享的：个人机器上运行的装置文件或者与程序相关的socket文件（仅与自身机器有关） 不变的：不会经常变动的数据（例如函式库、文件说明文件、主机服务配置文件等） 可变动的：经常改变的数据（例如登录文件、一般用户可自行收受的新闻组等） 事实上，FHS针对目录树结构仅定义出三层目录底下应该放置什么数据，分别是： /(root，根目录)：与开机系统有关 /usr(unix software resource)：与软件安装/执行有关 /var(variable)：与系统运作过程有关 目录树（directory tree）因为所有文件和目录都是由根目录开始，再一个一个分支下来，有点像树枝状，因此将这种目录配置方式称为“目录树”。它的主要特征有： 目录树的起点为根目录（/， root） 每一个目录不止能使用本地段的文件系统，也可以使用网络上的文件系统。例如可以利用Network File System（NFS）服务器挂载特定目录 每一个文件在此目录树种的文件名（包含完整路径）都是独一无二的 如果将整个目录树以图示的方法来显示，并将较为重要的文件数据列出来的话，目录树架构图大概如图所示： 绝对路径与相对路径根据文件名写法的不同，可以将路径（path）定义为相对路径（relative）与绝对路径（absolute），这两种文件名/路径的写法依据如下： 绝对路径：由根目录（/）开始写起，如 /etc/hosts 相对路径：相对于目前路径的文件名写法。只要不是/开头的写法都属于相对路径写法，如../Guest/ 思考：如果你当前在/home目录下，想进入/var/log目录，指令可以怎么写呢？如上述，绝对路径以根目录开始，相对路径是以“当前所在路径的相对位置”来表示的，那么可以这样写： cd ../var/log cd /var/log ./代表当前目录，../代表上一层目录，使用pwd指令可以查看当前路径的绝对路径 结束语至此，相信大家对Linux的文件属性与目录结构已经有了初步的认识。感谢大家进来浏览了小菜鸟的文章，下一次，我将与大家一起学习Linux文件与目录管理的相关知识，敬请捧场。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"CSS+图片简单实现五角星推荐指数","slug":"基于CSS简单实现五角星推荐指数","date":"2018-01-10T12:26:38.000Z","updated":"2018-01-10T12:48:16.000Z","comments":true,"path":"2018/01/10/基于CSS简单实现五角星推荐指数/","link":"","permalink":"http://yoursite.com/2018/01/10/基于CSS简单实现五角星推荐指数/","excerpt":"实现原理一张灰色五角星背景图至于底层，一张评分的亮色五角星图至于上层，利用CSS clip属性裁剪亮色五角星长度，实现推荐指数 HTML12345&lt;span class=\"recommended\"&gt; 推荐指数 &lt;i class=\"stars\"&gt;&lt;i class=\"inner\" :style=\"&#123;clip: rect&#125;\"&gt;&lt;/i&gt;&lt;/i&gt; &lt;i&gt;&#123;&#123;baseInfo.recommended&#125;&#125;&lt;/i&gt;&lt;/span&gt; CSS12345678910111213141516171819202122.stars &#123; display: inline-block; vertical-align: top; margin-top: 2px; margin-left: 5px; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars.png\"); background-size: contain; .inner &#123; display: inline-block; vertical-align: top; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars-active.png\"); background-size: contain; position: absolute; /*clip: rect(0 73px 13px 0);*/ &#125;&#125;","text":"实现原理一张灰色五角星背景图至于底层，一张评分的亮色五角星图至于上层，利用CSS clip属性裁剪亮色五角星长度，实现推荐指数 HTML12345&lt;span class=\"recommended\"&gt; 推荐指数 &lt;i class=\"stars\"&gt;&lt;i class=\"inner\" :style=\"&#123;clip: rect&#125;\"&gt;&lt;/i&gt;&lt;/i&gt; &lt;i&gt;&#123;&#123;baseInfo.recommended&#125;&#125;&lt;/i&gt;&lt;/span&gt; CSS12345678910111213141516171819202122.stars &#123; display: inline-block; vertical-align: top; margin-top: 2px; margin-left: 5px; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars.png\"); background-size: contain; .inner &#123; display: inline-block; vertical-align: top; width: 80px; height: 13px; line-height: 13px; background-image: url(\"../img/stars-active.png\"); background-size: contain; position: absolute; /*clip: rect(0 73px 13px 0);*/ &#125;&#125; JavaScript1self.rect = 'rect(0,' + (self.baseInfo.recommended / 5) * 80 + 'px, 13px, 0)' 效果","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"基于NodeJs防御csrf攻击","slug":"基于NodeJs防止csrf攻击","date":"2018-01-04T13:32:40.000Z","updated":"2018-01-10T13:36:38.000Z","comments":true,"path":"2018/01/04/基于NodeJs防止csrf攻击/","link":"","permalink":"http://yoursite.com/2018/01/04/基于NodeJs防止csrf攻击/","excerpt":"CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行 NodeJs下防御CSRF攻击思路验证 HTTP Referer 字段 HTTP 头中有一个 Referer 字段，它记录了该 HTTP 请求的来源地址，对该地址进行判断，如果同源则通过验证，否则拒绝请求123456789101112refererCheck(req, res, next)&#123; let referer = req.headers.referer; let refererHost = (referer &amp;&amp; referer.replace(/https?:\\/\\//ig, \"\").split(\"/\")[0]) || \"\"; let reg = new RegExp(\"\\\\.\" + app.config.baseURI.replace(/\\./g, \"\\\\.\") + \"$\"; if(!reg.test(refererHost))&#123; next(); &#125;&#125;app.get('/api/test', utils.refererCheck, (req, res, next) =&gt; &#123; // dosomething return xxx;&#125;); 以上，当请求/api/test时，站点A会劫持User(c)的请求并判断请求referer来源，如果发现来源于站点，则会拒绝请求","text":"CSRF简述CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 CSRF攻击原理及过程 User(C)通过浏览器访问并请求登录受信任站点A； 站点A通过验证并生成cookie返给浏览器 User(c)在没有退出站点A的情况下访问危险站点B 站点B接到请求后返回攻击代码，并发出一个请求要求访问第三方站点A 浏览器在接收到这些攻击性代码后，根据站点B的请求，在用户不知情的情况下携带Cookie信息，向站点A发出请求。站点A并不知道该请求其实是由B发起的，所以会根据User(C)的Cookie信息以C的权限处理该请求，导致来自站点B的恶意代码被执行 NodeJs下防御CSRF攻击思路验证 HTTP Referer 字段 HTTP 头中有一个 Referer 字段，它记录了该 HTTP 请求的来源地址，对该地址进行判断，如果同源则通过验证，否则拒绝请求123456789101112refererCheck(req, res, next)&#123; let referer = req.headers.referer; let refererHost = (referer &amp;&amp; referer.replace(/https?:\\/\\//ig, \"\").split(\"/\")[0]) || \"\"; let reg = new RegExp(\"\\\\.\" + app.config.baseURI.replace(/\\./g, \"\\\\.\") + \"$\"; if(!reg.test(refererHost))&#123; next(); &#125;&#125;app.get('/api/test', utils.refererCheck, (req, res, next) =&gt; &#123; // dosomething return xxx;&#125;); 以上，当请求/api/test时，站点A会劫持User(c)的请求并判断请求referer来源，如果发现来源于站点，则会拒绝请求 添加 token 并验证在服务器上生成一个token, web端发起的请求都带上token这个参数, 请求中的token与服务端的token不一致,则抛出错误.1、引入npm包csurf12const csrf = require('csurf');const csrfProtection = csrf(&#123;cookie: true&#125;); 2、校验请求1234app.get('/form', csrfProtection, function(req, res) &#123; // pass the csrfToken to the view res.render('send', &#123; csrfToken: req.csrfToken() &#125;)&#125;) 关于csurf模块首先看下源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function csurf (options) &#123; var opts = options || &#123;&#125; // get cookie options var cookie = getCookieOptions(opts.cookie) // get session options var sessionKey = opts.sessionKey || 'session' // get value getter var value = opts.value || defaultValue // token repo var tokens = new Tokens(opts) // ignored methods var ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods if (!Array.isArray(ignoreMethods)) &#123; throw new TypeError('option ignoreMethods must be an array') &#125; // generate lookup var ignoreMethod = getIgnoredMethods(ignoreMethods) return function csrf (req, res, next) &#123; // validate the configuration against request if (!verifyConfiguration(req, sessionKey, cookie)) &#123; return next(new Error('misconfigured csrf')) &#125; // get the secret from the request var secret = getSecret(req, sessionKey, cookie) var token // lazy-load token getter req.csrfToken = function csrfToken () &#123; var sec = !cookie ? getSecret(req, sessionKey, cookie) : secret // use cached token if secret has not changed if (token &amp;&amp; sec === secret) &#123; return token &#125; // generate &amp; set new secret if (sec === undefined) &#123; sec = tokens.secretSync() setSecret(req, res, sessionKey, sec, cookie) &#125; // update changed secret secret = sec // create new token token = tokens.create(secret) return token &#125; // generate &amp; set secret if (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie) &#125; // verify the incoming token if (!ignoreMethod[req.method] &amp;&amp; !tokens.verify(secret, value(req))) &#123; return next(createError(403, 'invalid csrf token', &#123; code: 'EBADCSRFTOKEN' &#125;)) &#125; next() &#125;&#125; 服务端如何生产成token, token存储的位置当csurf()方法被执行时，会为req添加一个方法csrfToken，该方法生成一个token, 并保存session中12345// generate &amp; set secretif (!secret) &#123; secret = tokens.secretSync() setSecret(req, res, sessionKey, secret, cookie)&#125; 服务端校验的token, 可能来自哪里12345678function defaultValue (req) &#123; return (req.body &amp;&amp; req.body._csrf) || (req.query &amp;&amp; req.query._csrf) || (req.headers['csrf-token']) || (req.headers['xsrf-token']) || (req.headers['x-csrf-token']) || (req.headers['x-xsrf-token'])&#125; 从代码上，如果csurlf初始化时没带任何参数，则校验的token使用使用默认的值，默认的token可能来自req.body, req.query, req.header 哪些请求不校验token1234// ignored methodsvar ignoreMethods = opts.ignoreMethods === undefined ? ['GET', 'HEAD', 'OPTIONS'] : opts.ignoreMethods 如果csurlf初始化时没带任何参数，则 get head option方法不做校验 参考文献1、npm csurf","categories":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/categories/Node/"}],"tags":[{"name":"Node","slug":"Node","permalink":"http://yoursite.com/tags/Node/"}]},{"title":"浅谈ES6新特性之promise篇","slug":"深入理解ES6新特性之promise篇","date":"2018-01-03T14:03:30.000Z","updated":"2018-01-08T14:15:54.367Z","comments":true,"path":"2018/01/03/深入理解ES6新特性之promise篇/","link":"","permalink":"http://yoursite.com/2018/01/03/深入理解ES6新特性之promise篇/","excerpt":"JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。","text":"JS单线程特性浏览器（或者说JS引擎）执行JS的机制是基于事件循环。 由于JS是单线程，所以同一时间只能执行一个任务，其他任务就得排队，后续任务必须等到前一个任务结束才能开始执行。为了避免因为某些长时间任务造成的无意义等待，JS引入了异步的概念，用另一个线程来管理异步任务。 同步任务直接在主线程队列中顺序执行，而异步任务会进入另一个任务队列，不会阻塞主线程。等到主线程队列空了（执行完了）的时候，就会去异步队列查询是否有可执行的异步任务了（异步任务通常进入异步队列之后还要等一些条件才能执行，如ajax请求、文件读写），如果某个异步任务可以执行了便加入主线程队列，以此循环。 回调金字塔一直以来，JavaScript处理异步都是以callback的方式，在callback的模型里边，我们假设需要执行一个异步队列，代码看起来可能像这样：1234567891011doSomethingAsync1(function()&#123; doSomethingAsync2(function()&#123; doSomethingAsync3(function()&#123; doSomethingAsync4(function()&#123; doSomethingAsync5(function()&#123; // code... &#125;); &#125;); &#125;); &#125;);&#125;); 可以发现一个问题，在回调函数嵌套层数不深的情况下，代码还算容易理解和维护，一旦嵌套层数加深，就会出现“回调金字塔”的问题。 近几年随着JavaScript开发模式的逐渐成熟，CommonJS规范顺势而生，其中就包括提出了Promise规范，Promise完全改变了js异步编程的写法，让异步编程变得十分的易于理解。 promise对象 Promise 对象用于一个异步操作的最终完成（或失败）及其结果值的表示。(简单点说就是处理异步请求。我们经常会做些承诺，如果我赢了你就嫁给我，如果输了我就嫁给你之类的诺言。这就是promise的中文含义：诺言，一个成功，一个失败。) 一个promise有以下几个状态： pending: 初始状态，成功或失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 Promise方法首先附上一段代码，以此来理解Promise.all()、Promise.race()、Promise.resolve()、Promise.reject()方法12345678910111213141516171819202122232425262728293031323334353637383940let promise1 = new Promise((resolve, reject) =&gt; &#123; resolve('promise1 OK')&#125;)let promise2 = new Promise((resolve, reject) =&gt; &#123; resolve('promise2 OK')&#125;)let promise3 = new Promise((resolve, reject) =&gt; &#123; reject('promise3 fail')&#125;)Promise.all([promise1, promise2]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;)Promise.all([promise1, promise3]).then(res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res =&gt; &#123; console.dir(`promise.all([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;)Promise.race([promise1, promise2]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise2])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise1, promise3]).then(res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise1, promise3])执行失败：$&#123;res&#125;`)&#125;);Promise.race([promise3, promise1]).then(res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行成功：$&#123;res&#125;`)&#125;,res=&gt;&#123; console.dir(`promise.race([promise3, promise1])执行失败：$&#123;res&#125;`)&#125;); 由以上代码及运行结果可见 Promise.all(iterable)Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例：var p = Promise.all([promise1, promise2]);该方法接受一个数组作为参数，p的状态由promise1、promise2决定，分两种情况： 只有promise1、promise2的状态都变成fulfilled，p的状态才会变成fulfilled，此时promise1、promise2的返回值组成一个数组，传递给p的回调函数。 只要promise1、promise2之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 Promise.race(iterable)该方法同Promise.all()一样的是：也用于将多个Promise实例包装成一个新的Promise实例：var p = Promise.race([promise1, promise3]); || var p = Promise.race([promise1, promise3]);不同的是：当promise1、promise3里的任意一个promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。 Promise.resolve(value)返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 Promise.reject(reason)返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 Promise原型Promise.prototype.constructor返回被创建的实例函数. 默认为 Promise 函数. Promise.prototype.then(onFulfilled, onRejected)添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve. Promise.prototype.catch(onRejected)添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果. 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Vue学习笔记之父子组件通信","slug":"Vue学习笔记之父子组件通信","date":"2017-12-27T13:29:29.000Z","updated":"2017-12-28T15:11:25.234Z","comments":true,"path":"2017/12/27/Vue学习笔记之父子组件通信/","link":"","permalink":"http://yoursite.com/2017/12/27/Vue学习笔记之父子组件通信/","excerpt":"定义父子组件HTML12345678&lt;div class=\"hello\"&gt; &lt;Welcome :message=\"msg\" @contact=\"comFromChildren\"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type=\"text\" name=\"username\" v-model=\"userName\"&gt; &lt;br&gt; &lt;input type=\"text\" name=\"age\" v-model=\"age\"&gt; &lt;br&gt; &lt;a href=\"javascript:;\" @click=\"addUser\"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125;","text":"定义父子组件HTML12345678&lt;div class=\"hello\"&gt; &lt;Welcome :message=\"msg\" @contact=\"comFromChildren\"&gt;&lt;/Welcome&gt; &lt;form&gt; &lt;input type=\"text\" name=\"username\" v-model=\"userName\"&gt; &lt;br&gt; &lt;input type=\"text\" name=\"age\" v-model=\"age\"&gt; &lt;br&gt; &lt;a href=\"javascript:;\" @click=\"addUser\"&gt;提交&lt;/a&gt; &lt;/form&gt;&lt;/div&gt; JavaScript123456789101112131415161718192021222324252627282930313233import Welcome from './welcome'export default &#123; name: 'hello', components: &#123;Welcome&#125;, data() &#123; return &#123; msg: 'Welcome to Your Vue.js App', userName: '', age: '' &#125; &#125;, methods: &#123; addUser() &#123; var self = this; self.$ajax(&#123; url: '/api/user/addUser', method: 'post', dataType: 'json', data: &#123; username: self.userName, age: self.age &#125; &#125;).then(res =&gt; &#123; if (res.data.success) &#123; console.log(res); &#125; &#125;) &#125;, comFromChildren: function () &#123; console.log('子组件传来信息啦') &#125; &#125;&#125; 定义子组件HTML1234&lt;template&gt; &lt;!--接受父组件传来的消息--&gt; &lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/template&gt; JavaScript1234567export default &#123; name: \"welcome\", props: ['message'], created() &#123; this.$emit('contact'); //通知父组件 &#125;&#125; 子组件接收父组件数据","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"webpack部署过程中遇到的问题","slug":"webpack-md","date":"2017-12-05T09:39:11.000Z","updated":"2017-12-18T12:27:12.184Z","comments":true,"path":"2017/12/05/webpack-md/","link":"","permalink":"http://yoursite.com/2017/12/05/webpack-md/","excerpt":"问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼……","text":"问题描述今天webpack部署新接手的项目的时候，npm install 好像加载不了package.json里面指定的依赖包！以至于项目在编译过程中有些静态资源文件不能require，翻阅各种文档，均不能解决，头疼…… 暂时解决方案从其他同事处拷贝了安装好的依赖包，放到项目代码中依然有问题，because……同事的操作系统是Windows，所以拷贝之后，依然有些包不能用：根据报错提示命令执行，终于解决： 暂时留坑在这里，等调试完项目之后再来回顾该问题 /(ㄒoㄒ)/~~","categories":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/categories/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"MacOS 下配置Apache本地域名服务器","slug":"MacOS-下配置Apache本地域名服务器","date":"2017-12-01T03:17:29.000Z","updated":"2017-12-01T05:56:14.005Z","comments":true,"path":"2017/12/01/MacOS-下配置Apache本地域名服务器/","link":"","permalink":"http://yoursite.com/2017/12/01/MacOS-下配置Apache本地域名服务器/","excerpt":"需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件","text":"需求来源在开发项目的过程中，遇到需要经过域名访问资源来进行debug的场景，但项目是静态资源项目，没有本地服务。SO，想到了通过配置本地Apache域名访问资源的办法。 实施过程配置本地hostsvi /etc/hosts，配置自己预期的域名到hosts文件 开启Apache虚拟主机功能vi /etc/apache2/httpd.conf打开Apache配置文件，找到Include /private/etc/apache2/extra/httpd-vhosts.conf，放开注释，开启虚拟主机功能: vi /etc/apache2/extra/httpd-vhosts.conf配置虚拟主机： 启动Apache服务，域名访问项目sudo apachectl start，好了，现在可以通过域名访问项目资源了：","categories":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/categories/服务器/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"http://yoursite.com/tags/Apache/"}]},{"title":"线上问题日志定位手段","slug":"online-problem-logs","date":"2017-11-30T03:50:30.000Z","updated":"2017-12-04T10:41:38.391Z","comments":true,"path":"2017/11/30/online-problem-logs/","link":"","permalink":"http://yoursite.com/2017/11/30/online-problem-logs/","excerpt":"背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径：","text":"背景 项目在上线上环境之后，由于项目部署在服务器上，发生问题时本地无法debug，因此日志变得尤为重要。监控线上日志也成为线上问题定位的有效手段之一 日志监控以Linux系统下的项目部署为例，首先进入项目线上部署服务器，找到项目路径以及日志文件生成路径： 找到日志之后，就可以对指定级别的日志文件进行实时监控啦。一般发生问题时该监控error日志，本文以info日志为例： 然后进入软件系统进行相应操作，即可看见操作产生的对应日志了","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux下查找包含指定内容的文件","slug":"Linux","date":"2017-11-29T16:00:00.000Z","updated":"2017-12-04T10:39:46.564Z","comments":true,"path":"2017/11/30/Linux/","link":"","permalink":"http://yoursite.com/2017/11/30/Linux/","excerpt":"背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类|标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图：","text":"背景在hexo上发布第一篇文章之后，对文章进行了分类和打标，当我点击分类|标签查看该下面的文章是，惊奇的发现分类的样式有点小瑕疵。你知道的，强迫症肯定受不了，于是……审查元素，想对不满意的地方进行样式调整。OK，成功找到有问题的样式标签，如图： 嗯，可以准备下手修改样式了！but……这个样式表在哪里啊？翻遍了文件夹都没找到对应的这个main.css啊！没关系，接下来该我们本文的主角出场了 机智的find命令以本人对Linux模糊的记忆，搜索到了强悍的find命令find .|xargs grep -ri &quot;xxx&quot;：执行，good，找到了一大堆文件：修改样式，上传，查看blog样式，perfect，手工！ 小插曲 为了省去本文的标题、分类、标签等一系列配置，我打算直接复用上一篇文章的配置。这样的话我首先用vim命令新建了该文章的文件Linux下查找文件/内容之find命令.md，然后cat xx.md &gt; Linux下查找文件/内容之find命令.md把xx文件的内容复制到了该文件","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}